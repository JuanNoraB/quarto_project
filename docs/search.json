[
  {
    "objectID": "RESUMEN_MODELOS.html",
    "href": "RESUMEN_MODELOS.html",
    "title": "Resumen de Modelos de Machine Learning - Aprendizaje Supervisado",
    "section": "",
    "text": "Este documento presenta los resultados de dos problemas independientes de aprendizaje supervisado utilizando datos abiertos de Ecuador: un modelo de regresión para predecir nivel socioeconómico y un modelo de clasificación binaria para predecir siniestros de tránsito letales.\n\n\n\n\n\n\nPredecir el decil socioeconómico (1-10) de hogares ecuatorianos basado en características de vivienda y acceso a servicios básicos.\n\n\n\n\nFuente: Datos Abiertos Ecuador - Encuesta de Hogares 2018\nTamaño: 2,565,433 registros de hogares\nVariables: 17 features (materiales de vivienda, servicios básicos, ubicación geográfica)\nVariable objetivo: Decil socioeconómico (1 = más pobre, 10 = más rico)\n\n\n\n\n\nModelo: LinearRegression con Pipeline\nPreprocesamiento: StandardScaler + LabelEncoder\nDivisión: 80% entrenamiento, 20% prueba (estratificada)\nFeatures principales: Tipo de vivienda, materiales (techo/piso/paredes), servicios (agua, electricidad, internet, TV cable)\n\n\n\n\n\n\n\nMétrica\nValor\nInterpretación\n\n\n\n\nR²\n0.38\nExplica 38% de la varianza (capacidad moderada)\n\n\nMSE\n3.46\nError cuadrático medio aceptable\n\n\nRMSE\n1.86\nError promedio de ~2 deciles\n\n\n\n\n\n\n\nTotal de personas por hogar (coef: -1.96) → Hogares más grandes tienden a menor decil\nTotal de hogares por área (coef: +1.86) → Más hogares concentrados = mayor decil\nMaterial del piso (coef: -0.50) → Mejores materiales = mayor decil\nAcceso a TV cable/satelital (coef: -0.39) → Acceso mejora el decil\nUbicación urbana/rural (coef: -0.29) → Área urbana = mayor decil\n\n\n\n\n\nEl modelo identifica patrones claros entre infraestructura de vivienda y nivel socioeconómico\nServicios básicos (internet, TV, teléfono) son predictores importantes del bienestar\nÁrea geográfica influye significativamente en el nivel socioeconómico\nAplicaciones: Identificación de hogares vulnerables, planificación de programas sociales, inversión en infraestructura\n\n\n\n\n\n\n\n\nPredecir si un siniestro de tránsito será letal (con fallecidos) o no letal basado en características del accidente.\n\n\n\n\nFuente: Datos Abiertos Ecuador - INEC Siniestros de Tránsito 2019\nTamaño: 24,595 siniestros de tránsito\nVariable objetivo: Binaria (Letal vs No Letal)\nDistribución: 8.01% letales, 91.99% no letales (clases desbalanceadas)\n\n\n\n\n\nModelo: LogisticRegression con Pipeline\nPreprocesamiento: OneHotEncoder + StandardScaler\nDivisión: 80% entrenamiento, 20% prueba (estratificada)\nFeatures principales: Ubicación (provincia, cantón), tipo de siniestro, causa, hora, zona urbana/rural\n\n\n\n\n\n\n\n\n\n\n\n\nMétrica\nValor\nInterpretación\n\n\n\n\nAccuracy\n92.4%\nClasifica correctamente 9 de cada 10 casos\n\n\nPrecision\n66.1%\nDe los predichos como letales, 66% son realmente letales\n\n\nRecall\n9.9%\nSolo detecta 1 de cada 10 siniestros letales reales\n\n\nF1-Score\n0.17\nBalance bajo entre precision y recall\n\n\nROC-AUC\n0.81\nExcelente capacidad de discriminación\n\n\n\n\n\n\n\nCantón El Carmen → Mayor riesgo de siniestros letales\nProvincia Cotopaxi → Zona de alto riesgo\nClase “Caída de Pasajeros” → Menor probabilidad de ser letal (coef negativo)\nCantón Puerto Quito → Alto riesgo de letalidad\nZona urbana → Menor riesgo que zonas rurales\n\n\n\n\n\nEl modelo es conservador: prefiere no clasificar como letal (bajo recall)\nExcelente accuracy general pero baja detección de casos letales\nFactores geográficos son los más predictivos de letalidad\nProblema de clases desbalanceadas afecta el rendimiento\nAplicaciones: Prevención de accidentes, asignación de recursos de emergencia, políticas de seguridad vial\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAspecto\nRegresión\nClasificación\n\n\n\n\nTipo de problema\nPredicción continua\nPredicción binaria\n\n\nRendimiento\nModerado (R²=0.38)\nAlto (Acc=92.4%)\n\n\nPrincipal desafío\nVarianza no explicada\nClases desbalanceadas\n\n\nFactor más importante\nTotal personas/hogares\nUbicación geográfica\n\n\nAplicación práctica\nPolíticas sociales\nSeguridad vial\n\n\n\n\n\n\n\n\n# Regresión\nPipeline([\n    ('scaler', StandardScaler()),\n    ('regressor', LinearRegression())\n])\n\n# Clasificación\nPipeline([\n    ('preprocessor', ColumnTransformer([\n        ('num', StandardScaler(), numerical_features),\n        ('cat', OneHotEncoder(), categorical_features)\n    ])),\n    ('classifier', LogisticRegression())\n])\n\n\n\n\nRegresión: Valores reales vs predichos, curva de aprendizaje, distribución de errores\nClasificación: Matriz de confusión, curva ROC, distribución de probabilidades, métricas de evaluación\n\n\n\n\n\n\nAmbos modelos demuestran la aplicabilidad del aprendizaje supervisado a problemas reales ecuatorianos\nFactores geográficos emergen como predictores importantes en ambos casos\nPipeline de Scikit-learn facilita el preprocesamiento y entrenamiento sistemático\nDatos gubernamentales abiertos proporcionan oportunidades valiosas para análisis predictivo\nConsideraciones éticas son importantes, especialmente en aplicaciones de política pública\n\n\n\n\n\n\n\n\nregresion_hogares.py - Código principal del modelo\ndecil_reales_vs_predichos.png - Comparación de predicciones\ncurva_aprendizaje_decil.png - Curva de aprendizaje\nimportancia_factores_decil.png - Importancia de features\n\n\n\n\n\nclasificacion_binaria.py - Código principal del modelo\nmatriz_confusion.png - Matriz de confusión\ncurva_roc.png - Curva ROC\ndistribucion_probabilidades.png - Distribución de probabilidades\nmetricas_evaluacion.png - Métricas de evaluación\n\n\nProyecto desarrollado como parte del curso de Machine Learning - Aplicación de técnicas de aprendizaje supervisado con datos abiertos de Ecuador."
  },
  {
    "objectID": "RESUMEN_MODELOS.html#descripción-general",
    "href": "RESUMEN_MODELOS.html#descripción-general",
    "title": "Resumen de Modelos de Machine Learning - Aprendizaje Supervisado",
    "section": "",
    "text": "Este documento presenta los resultados de dos problemas independientes de aprendizaje supervisado utilizando datos abiertos de Ecuador: un modelo de regresión para predecir nivel socioeconómico y un modelo de clasificación binaria para predecir siniestros de tránsito letales."
  },
  {
    "objectID": "RESUMEN_MODELOS.html#modelo-de-regresión---predicción-de-decil-socioeconómico",
    "href": "RESUMEN_MODELOS.html#modelo-de-regresión---predicción-de-decil-socioeconómico",
    "title": "Resumen de Modelos de Machine Learning - Aprendizaje Supervisado",
    "section": "",
    "text": "Predecir el decil socioeconómico (1-10) de hogares ecuatorianos basado en características de vivienda y acceso a servicios básicos.\n\n\n\n\nFuente: Datos Abiertos Ecuador - Encuesta de Hogares 2018\nTamaño: 2,565,433 registros de hogares\nVariables: 17 features (materiales de vivienda, servicios básicos, ubicación geográfica)\nVariable objetivo: Decil socioeconómico (1 = más pobre, 10 = más rico)\n\n\n\n\n\nModelo: LinearRegression con Pipeline\nPreprocesamiento: StandardScaler + LabelEncoder\nDivisión: 80% entrenamiento, 20% prueba (estratificada)\nFeatures principales: Tipo de vivienda, materiales (techo/piso/paredes), servicios (agua, electricidad, internet, TV cable)\n\n\n\n\n\n\n\nMétrica\nValor\nInterpretación\n\n\n\n\nR²\n0.38\nExplica 38% de la varianza (capacidad moderada)\n\n\nMSE\n3.46\nError cuadrático medio aceptable\n\n\nRMSE\n1.86\nError promedio de ~2 deciles\n\n\n\n\n\n\n\nTotal de personas por hogar (coef: -1.96) → Hogares más grandes tienden a menor decil\nTotal de hogares por área (coef: +1.86) → Más hogares concentrados = mayor decil\nMaterial del piso (coef: -0.50) → Mejores materiales = mayor decil\nAcceso a TV cable/satelital (coef: -0.39) → Acceso mejora el decil\nUbicación urbana/rural (coef: -0.29) → Área urbana = mayor decil\n\n\n\n\n\nEl modelo identifica patrones claros entre infraestructura de vivienda y nivel socioeconómico\nServicios básicos (internet, TV, teléfono) son predictores importantes del bienestar\nÁrea geográfica influye significativamente en el nivel socioeconómico\nAplicaciones: Identificación de hogares vulnerables, planificación de programas sociales, inversión en infraestructura"
  },
  {
    "objectID": "RESUMEN_MODELOS.html#modelo-de-clasificación-binaria---predicción-de-siniestros-letales",
    "href": "RESUMEN_MODELOS.html#modelo-de-clasificación-binaria---predicción-de-siniestros-letales",
    "title": "Resumen de Modelos de Machine Learning - Aprendizaje Supervisado",
    "section": "",
    "text": "Predecir si un siniestro de tránsito será letal (con fallecidos) o no letal basado en características del accidente.\n\n\n\n\nFuente: Datos Abiertos Ecuador - INEC Siniestros de Tránsito 2019\nTamaño: 24,595 siniestros de tránsito\nVariable objetivo: Binaria (Letal vs No Letal)\nDistribución: 8.01% letales, 91.99% no letales (clases desbalanceadas)\n\n\n\n\n\nModelo: LogisticRegression con Pipeline\nPreprocesamiento: OneHotEncoder + StandardScaler\nDivisión: 80% entrenamiento, 20% prueba (estratificada)\nFeatures principales: Ubicación (provincia, cantón), tipo de siniestro, causa, hora, zona urbana/rural\n\n\n\n\n\n\n\n\n\n\n\n\nMétrica\nValor\nInterpretación\n\n\n\n\nAccuracy\n92.4%\nClasifica correctamente 9 de cada 10 casos\n\n\nPrecision\n66.1%\nDe los predichos como letales, 66% son realmente letales\n\n\nRecall\n9.9%\nSolo detecta 1 de cada 10 siniestros letales reales\n\n\nF1-Score\n0.17\nBalance bajo entre precision y recall\n\n\nROC-AUC\n0.81\nExcelente capacidad de discriminación\n\n\n\n\n\n\n\nCantón El Carmen → Mayor riesgo de siniestros letales\nProvincia Cotopaxi → Zona de alto riesgo\nClase “Caída de Pasajeros” → Menor probabilidad de ser letal (coef negativo)\nCantón Puerto Quito → Alto riesgo de letalidad\nZona urbana → Menor riesgo que zonas rurales\n\n\n\n\n\nEl modelo es conservador: prefiere no clasificar como letal (bajo recall)\nExcelente accuracy general pero baja detección de casos letales\nFactores geográficos son los más predictivos de letalidad\nProblema de clases desbalanceadas afecta el rendimiento\nAplicaciones: Prevención de accidentes, asignación de recursos de emergencia, políticas de seguridad vial"
  },
  {
    "objectID": "RESUMEN_MODELOS.html#comparación-de-modelos",
    "href": "RESUMEN_MODELOS.html#comparación-de-modelos",
    "title": "Resumen de Modelos de Machine Learning - Aprendizaje Supervisado",
    "section": "",
    "text": "Aspecto\nRegresión\nClasificación\n\n\n\n\nTipo de problema\nPredicción continua\nPredicción binaria\n\n\nRendimiento\nModerado (R²=0.38)\nAlto (Acc=92.4%)\n\n\nPrincipal desafío\nVarianza no explicada\nClases desbalanceadas\n\n\nFactor más importante\nTotal personas/hogares\nUbicación geográfica\n\n\nAplicación práctica\nPolíticas sociales\nSeguridad vial"
  },
  {
    "objectID": "RESUMEN_MODELOS.html#metodología-técnica",
    "href": "RESUMEN_MODELOS.html#metodología-técnica",
    "title": "Resumen de Modelos de Machine Learning - Aprendizaje Supervisado",
    "section": "",
    "text": "# Regresión\nPipeline([\n    ('scaler', StandardScaler()),\n    ('regressor', LinearRegression())\n])\n\n# Clasificación\nPipeline([\n    ('preprocessor', ColumnTransformer([\n        ('num', StandardScaler(), numerical_features),\n        ('cat', OneHotEncoder(), categorical_features)\n    ])),\n    ('classifier', LogisticRegression())\n])\n\n\n\n\nRegresión: Valores reales vs predichos, curva de aprendizaje, distribución de errores\nClasificación: Matriz de confusión, curva ROC, distribución de probabilidades, métricas de evaluación"
  },
  {
    "objectID": "RESUMEN_MODELOS.html#conclusiones-generales",
    "href": "RESUMEN_MODELOS.html#conclusiones-generales",
    "title": "Resumen de Modelos de Machine Learning - Aprendizaje Supervisado",
    "section": "",
    "text": "Ambos modelos demuestran la aplicabilidad del aprendizaje supervisado a problemas reales ecuatorianos\nFactores geográficos emergen como predictores importantes en ambos casos\nPipeline de Scikit-learn facilita el preprocesamiento y entrenamiento sistemático\nDatos gubernamentales abiertos proporcionan oportunidades valiosas para análisis predictivo\nConsideraciones éticas son importantes, especialmente en aplicaciones de política pública"
  },
  {
    "objectID": "RESUMEN_MODELOS.html#archivos-del-proyecto",
    "href": "RESUMEN_MODELOS.html#archivos-del-proyecto",
    "title": "Resumen de Modelos de Machine Learning - Aprendizaje Supervisado",
    "section": "",
    "text": "regresion_hogares.py - Código principal del modelo\ndecil_reales_vs_predichos.png - Comparación de predicciones\ncurva_aprendizaje_decil.png - Curva de aprendizaje\nimportancia_factores_decil.png - Importancia de features\n\n\n\n\n\nclasificacion_binaria.py - Código principal del modelo\nmatriz_confusion.png - Matriz de confusión\ncurva_roc.png - Curva ROC\ndistribucion_probabilidades.png - Distribución de probabilidades\nmetricas_evaluacion.png - Métricas de evaluación\n\n\nProyecto desarrollado como parte del curso de Machine Learning - Aplicación de técnicas de aprendizaje supervisado con datos abiertos de Ecuador."
  },
  {
    "objectID": "indexx.html",
    "href": "indexx.html",
    "title": "Primer proyecto en Quarto",
    "section": "",
    "text": "Este documento presenta un análisis completo de machine learning utilizando Quarto para la documentación y visualización de resultados.\n\n\n\nExplorar y analizar un conjunto de datos\nImplementar diferentes algoritmos de machine learning\nComparar el rendimiento de los modelos\nVisualizar los resultados de manera clara"
  },
  {
    "objectID": "indexx.html#objetivos",
    "href": "indexx.html#objetivos",
    "title": "Primer proyecto en Quarto",
    "section": "",
    "text": "Explorar y analizar un conjunto de datos\nImplementar diferentes algoritmos de machine learning\nComparar el rendimiento de los modelos\nVisualizar los resultados de manera clara"
  },
  {
    "objectID": "indexx.html#estadísticas-descriptivas",
    "href": "indexx.html#estadísticas-descriptivas",
    "title": "Primer proyecto en Quarto",
    "section": "Estadísticas Descriptivas",
    "text": "Estadísticas Descriptivas\n\n\nCode\n# Estadísticas descriptivas\nprint(\"Estadísticas descriptivas:\")\ndf.describe()\n\n\nEstadísticas descriptivas:\n\n\n\n\n\n\n\n\n\nfeature_1\nfeature_2\nfeature_3\ntarget\n\n\n\n\ncount\n1000.000000\n1000.000000\n1000.000000\n1000.000000\n\n\nmean\n0.019332\n0.070836\n0.005834\n0.379000\n\n\nstd\n0.979216\n0.997454\n0.983454\n0.485381\n\n\nmin\n-3.241267\n-2.940389\n-3.019512\n0.000000\n\n\n25%\n-0.647590\n-0.606242\n-0.648000\n0.000000\n\n\n50%\n0.025301\n0.063077\n-0.000251\n0.000000\n\n\n75%\n0.647944\n0.728882\n0.660915\n1.000000\n\n\nmax\n3.852731\n3.193108\n3.926238\n1.000000"
  },
  {
    "objectID": "indexx.html#visualización-de-los-datos",
    "href": "indexx.html#visualización-de-los-datos",
    "title": "Primer proyecto en Quarto",
    "section": "Visualización de los Datos",
    "text": "Visualización de los Datos\n\n\nCode\n# Crear subplots\nfig, axes = plt.subplots(2, 2, figsize=(12, 10))\n\n# Histograma de feature_1\naxes[0, 0].hist(df['feature_1'], bins=30, alpha=0.7, color='skyblue')\naxes[0, 0].set_title('Distribución de Feature 1')\naxes[0, 0].set_xlabel('Valor')\naxes[0, 0].set_ylabel('Frecuencia')\n\n# Scatter plot feature_1 vs feature_2\nscatter = axes[0, 1].scatter(df['feature_1'], df['feature_2'], \n                           c=df['target'], cmap='viridis', alpha=0.6)\naxes[0, 1].set_title('Feature 1 vs Feature 2')\naxes[0, 1].set_xlabel('Feature 1')\naxes[0, 1].set_ylabel('Feature 2')\nplt.colorbar(scatter, ax=axes[0, 1])\n\n# Box plot por target\ndf.boxplot(column='feature_1', by='target', ax=axes[1, 0])\naxes[1, 0].set_title('Feature 1 por Target')\naxes[1, 0].set_xlabel('Target')\n\n# Correlación\ncorr_matrix = df.corr()\nsns.heatmap(corr_matrix, annot=True, cmap='coolwarm', center=0, ax=axes[1, 1])\naxes[1, 1].set_title('Matriz de Correlación')\n\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "indexx.html#modelo-1-regresión-logística",
    "href": "indexx.html#modelo-1-regresión-logística",
    "title": "Primer proyecto en Quarto",
    "section": "Modelo 1: Regresión Logística",
    "text": "Modelo 1: Regresión Logística\n\n\nCode\n# Entrenar modelo de regresión logística\nlr_model = LogisticRegression(random_state=42, max_iter=1000)\nlr_model.fit(X_train, y_train)\n\n# Predicciones\nlr_pred = lr_model.predict(X_test)\nlr_pred_proba = lr_model.predict_proba(X_test)[:, 1]\n\nprint(\"Regresión Logística - Métricas:\")\nprint(classification_report(y_test, lr_pred))\n\n\nRegresión Logística - Métricas:\n              precision    recall  f1-score   support\n\n           0       0.62      1.00      0.77       124\n           1       0.00      0.00      0.00        76\n\n    accuracy                           0.62       200\n   macro avg       0.31      0.50      0.38       200\nweighted avg       0.38      0.62      0.47       200"
  },
  {
    "objectID": "indexx.html#modelo-2-random-forest",
    "href": "indexx.html#modelo-2-random-forest",
    "title": "Primer proyecto en Quarto",
    "section": "Modelo 2: Random Forest",
    "text": "Modelo 2: Random Forest\n\n\nCode\n# Entrenar modelo Random Forest\nrf_model = RandomForestClassifier(n_estimators=100, random_state=42)\nrf_model.fit(X_train, y_train)\n\n# Predicciones\nrf_pred = rf_model.predict(X_test)\nrf_pred_proba = rf_model.predict_proba(X_test)[:, 1]\n\nprint(\"Random Forest - Métricas:\")\nprint(classification_report(y_test, rf_pred))\n\n\nRandom Forest - Métricas:\n              precision    recall  f1-score   support\n\n           0       0.58      0.72      0.64       124\n           1       0.24      0.14      0.18        76\n\n    accuracy                           0.50       200\n   macro avg       0.41      0.43      0.41       200\nweighted avg       0.45      0.50      0.47       200"
  },
  {
    "objectID": "indexx.html#matriz-de-confusión",
    "href": "indexx.html#matriz-de-confusión",
    "title": "Primer proyecto en Quarto",
    "section": "Matriz de Confusión",
    "text": "Matriz de Confusión\n\n\nCode\nfig, axes = plt.subplots(1, 2, figsize=(12, 5))\n\n# Matriz de confusión para Regresión Logística\ncm_lr = confusion_matrix(y_test, lr_pred)\nsns.heatmap(cm_lr, annot=True, fmt='d', cmap='Blues', ax=axes[0])\naxes[0].set_title('Regresión Logística')\naxes[0].set_xlabel('Predicción')\naxes[0].set_ylabel('Valor Real')\n\n# Matriz de confusión para Random Forest\ncm_rf = confusion_matrix(y_test, rf_pred)\nsns.heatmap(cm_rf, annot=True, fmt='d', cmap='Greens', ax=axes[1])\naxes[1].set_title('Random Forest')\naxes[1].set_xlabel('Predicción')\naxes[1].set_ylabel('Valor Real')\n\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "indexx.html#comparación-de-importancia-de-características",
    "href": "indexx.html#comparación-de-importancia-de-características",
    "title": "Primer proyecto en Quarto",
    "section": "Comparación de Importancia de Características",
    "text": "Comparación de Importancia de Características\n\n\nCode\n# Importancia de características para Random Forest\nfeature_importance = pd.DataFrame({\n    'feature': X.columns,\n    'importance': rf_model.feature_importances_\n}).sort_values('importance', ascending=True)\n\nplt.figure(figsize=(10, 6))\nplt.barh(feature_importance['feature'], feature_importance['importance'])\nplt.title('Importancia de Características - Random Forest')\nplt.xlabel('Importancia')\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "indexx.html#resumen-de-resultados",
    "href": "indexx.html#resumen-de-resultados",
    "title": "Primer proyecto en Quarto",
    "section": "Resumen de Resultados",
    "text": "Resumen de Resultados\nLos modelos implementados muestran diferentes niveles de rendimiento:\n\nRegresión Logística: Modelo lineal simple y rápido\nRandom Forest: Modelo más complejo con mejor capacidad de capturar relaciones no lineales"
  },
  {
    "objectID": "indexx.html#próximos-pasos",
    "href": "indexx.html#próximos-pasos",
    "title": "Primer proyecto en Quarto",
    "section": "Próximos Pasos",
    "text": "Próximos Pasos\n\nProbar otros algoritmos (SVM, XGBoost, etc.)\nOptimizar hiperparámetros\nImplementar validación cruzada\nAnálisis de más características\n\n\nDocumento generado con Quarto - {format(Sys.time(), “%Y-%m-%d %H:%M:%S”)}"
  },
  {
    "objectID": "clase_2-10-2025/clasificaion.html",
    "href": "clase_2-10-2025/clasificaion.html",
    "title": "Clasificación",
    "section": "",
    "text": "Code\nfrom sklearn.datasets import load_breast_cancer\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, ConfusionMatrixDisplay\n\n\n\nCargar el dataset\n\n\nCode\ndata = load_breast_cancer()\ndata\n\nX = data.data\ny = data.target\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42,stratify=y)\n\n\n#entrenar modelo\n\n\nCode\nmodel = LogisticRegression(max_iter=1000)\nmodel.fit(X_train, y_train)\n\n\n/home/juanchx/anaconda3/lib/python3.11/site-packages/sklearn/linear_model/_logistic.py:458: ConvergenceWarning:\n\nlbfgs failed to converge (status=1):\nSTOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n\nIncrease the number of iterations (max_iter) or scale the data as shown in:\n    https://scikit-learn.org/stable/modules/preprocessing.html\nPlease also refer to the documentation for alternative solver options:\n    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n\n\n\nLogisticRegression(max_iter=1000)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression(max_iter=1000)\n\n\n#predecir\n\n\nCode\ny_pred = model.predict(X_test)\n\n\n#metricas\n\n\nCode\naccuracy = accuracy_score(y_test, y_pred)\nprecision = precision_score(y_test, y_pred)\nrecall = recall_score(y_test, y_pred)\nf1 = f1_score(y_test, y_pred)"
  },
  {
    "objectID": "eda.html",
    "href": "eda.html",
    "title": "Exploratory Data Analysis (EDA)",
    "section": "",
    "text": "Exploratory Data Analysis (EDA) is one of the fundamental steps in any data science process. It allows us to understand the structure, detect anomalies, and uncover patterns in the data before modeling.\n\n“Without EDA, you’re not doing data science, you’re just guessing.”\n\nEDA combines statistics, programming, and visualization to explore datasets. This report is designed to help you practice these core skills using real-world data.\n\n\nWe will use the movies dataset from vega-datasets, which includes information about thousands of films such as their ratings, genres, duration, and box office revenue.\nLet’s load and preview the dataset:\n\n\nCode\nimport pandas as pd\nimport altair as alt\nfrom vega_datasets import data\n\n# Load dataset\nmovies = data.movies()\n\n# Show first rows\nmovies.head()\n\n\n\n\n\n\n\n\n\nTitle\nUS_Gross\nWorldwide_Gross\nUS_DVD_Sales\nProduction_Budget\nRelease_Date\nMPAA_Rating\nRunning_Time_min\nDistributor\nSource\nMajor_Genre\nCreative_Type\nDirector\nRotten_Tomatoes_Rating\nIMDB_Rating\nIMDB_Votes\n\n\n\n\n0\nThe Land Girls\n146083.0\n146083.0\nNaN\n8000000.0\nJun 12 1998\nR\nNaN\nGramercy\nNone\nNone\nNone\nNone\nNaN\n6.1\n1071.0\n\n\n1\nFirst Love, Last Rites\n10876.0\n10876.0\nNaN\n300000.0\nAug 07 1998\nR\nNaN\nStrand\nNone\nDrama\nNone\nNone\nNaN\n6.9\n207.0\n\n\n2\nI Married a Strange Person\n203134.0\n203134.0\nNaN\n250000.0\nAug 28 1998\nNone\nNaN\nLionsgate\nNone\nComedy\nNone\nNone\nNaN\n6.8\n865.0\n\n\n3\nLet's Talk About Sex\n373615.0\n373615.0\nNaN\n300000.0\nSep 11 1998\nNone\nNaN\nFine Line\nNone\nComedy\nNone\nNone\n13.0\nNaN\nNaN\n\n\n4\nSlam\n1009819.0\n1087521.0\nNaN\n1000000.0\nOct 09 1998\nR\nNaN\nTrimark\nOriginal Screenplay\nDrama\nContemporary Fiction\nNone\n62.0\n3.4\n165.0\n\n\n\n\n\n\n\nNow, let’s examine the shape (number of rows and columns) of the dataset:\n\n\nCode\nmovies.shape\n\n\n(3201, 16)\n\n\nThis tells us how many entries (rows) and features (columns) are present in the dataset.\n\n\n\nBefore diving deeper into the data, it’s useful to explore some key metadata:\n\n✅ The column names and their data types\n⚠️ The presence of missing values\n📊 Summary statistics for numeric columns\n\n\n\nUnderstanding the structure of the dataset helps us know what type of data we’re dealing with.\n\n\nCode\nmovies.dtypes\n\n\nTitle                      object\nUS_Gross                  float64\nWorldwide_Gross           float64\nUS_DVD_Sales              float64\nProduction_Budget         float64\nRelease_Date               object\nMPAA_Rating                object\nRunning_Time_min          float64\nDistributor                object\nSource                     object\nMajor_Genre                object\nCreative_Type              object\nDirector                   object\nRotten_Tomatoes_Rating    float64\nIMDB_Rating               float64\nIMDB_Votes                float64\ndtype: object\n\n\nWe can also use .info() for a more complete summary, including non-null counts:\n\n\nCode\n# Overview of the dataset\nmovies.info()\n\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 3201 entries, 0 to 3200\nData columns (total 16 columns):\n #   Column                  Non-Null Count  Dtype  \n---  ------                  --------------  -----  \n 0   Title                   3200 non-null   object \n 1   US_Gross                3194 non-null   float64\n 2   Worldwide_Gross         3194 non-null   float64\n 3   US_DVD_Sales            564 non-null    float64\n 4   Production_Budget       3200 non-null   float64\n 5   Release_Date            3201 non-null   object \n 6   MPAA_Rating             2596 non-null   object \n 7   Running_Time_min        1209 non-null   float64\n 8   Distributor             2969 non-null   object \n 9   Source                  2836 non-null   object \n 10  Major_Genre             2926 non-null   object \n 11  Creative_Type           2755 non-null   object \n 12  Director                1870 non-null   object \n 13  Rotten_Tomatoes_Rating  2321 non-null   float64\n 14  IMDB_Rating             2988 non-null   float64\n 15  IMDB_Votes              2988 non-null   float64\ndtypes: float64(8), object(8)\nmemory usage: 400.3+ KB\n\n\n\n\n\n\nDetecting and handling missing values is a critical step in any EDA process. Missing data can bias analysis or break downstream models if not handled properly.\n\nDetect patterns in missingness\nIdentify if some columns are almost entirely null\nDecide whether to drop or impute certain variables\n\n\n\nLet’s start by computing the percentage of missing values in each column:\n\n\nCode\nnan_percent = movies.isna().mean() * 100\nnan_percent_sorted = nan_percent.sort_values(ascending=False).round(2)\nnan_percent_sorted\n\n\nUS_DVD_Sales              82.38\nRunning_Time_min          62.23\nDirector                  41.58\nRotten_Tomatoes_Rating    27.49\nMPAA_Rating               18.90\nCreative_Type             13.93\nSource                    11.40\nMajor_Genre                8.59\nDistributor                7.25\nIMDB_Rating                6.65\nIMDB_Votes                 6.65\nUS_Gross                   0.22\nWorldwide_Gross            0.22\nTitle                      0.03\nProduction_Budget          0.03\nRelease_Date               0.00\ndtype: float64\n\n\n\n\n\nTo visualize missing values with Altair, we need to reshape the data into a long format where each missing value is a row:\n\n\nCode\nmovies_nans = movies.isna().reset_index().melt(\n    id_vars='index',\n    var_name='column',\n    value_name=\"NaN\"\n)\nmovies_nans\n\n\n\n\n\n\n\n\n\nindex\ncolumn\nNaN\n\n\n\n\n0\n0\nTitle\nFalse\n\n\n1\n1\nTitle\nFalse\n\n\n2\n2\nTitle\nFalse\n\n\n3\n3\nTitle\nFalse\n\n\n4\n4\nTitle\nFalse\n\n\n...\n...\n...\n...\n\n\n51211\n3196\nIMDB_Votes\nFalse\n\n\n51212\n3197\nIMDB_Votes\nTrue\n\n\n51213\n3198\nIMDB_Votes\nFalse\n\n\n51214\n3199\nIMDB_Votes\nFalse\n\n\n51215\n3200\nIMDB_Votes\nFalse\n\n\n\n\n51216 rows × 3 columns\n\n\n\n\n\n\nThis heatmap shows where missing values occur across rows and columns. Patterns may indicate:\n\nColumns with consistently missing values\nEntire rows with large gaps\nCorrelated missingness between variables\n\nTo avoid limitations in the number of rows rendered by Altair, we disable the max rows warning:\n\n\nCode\nalt.data_transformers.disable_max_rows()\n\n\nDataTransformerRegistry.enable('default')\n\n\nNow we can create the heatmap:\n\n\nCode\nalt.Chart(movies_nans).mark_rect().encode(\n    alt.X('index:O'),\n    alt.Y('column'),\n    alt.Color('NaN')\n).properties(\n    width=1000\n)\n\n\n\n\n\n\n\nThis plot can help identify columns or rows with critical data issues.\n\n\n\nIn many real-world cases, we may decide to remove columns that have too many missing values. Let’s set a threshold of 70%:\n\n\nCode\nthreshold_nan = 70 # in percent\ncols_to_drop = nan_percent[nan_percent&gt;threshold_nan].index\ncols_to_drop\n\n\nIndex(['US_DVD_Sales'], dtype='object')\n\n\nThese columns have more than 70% missing values and may not be useful for analysis.\n\n\n\n\nFinally, we drop the selected columns and inspect the updated dataset:\n\n\nCode\nmovies_cleaned = movies.drop(columns=cols_to_drop)\nmovies_cleaned\n\n\n\n\n\n\n\n\n\nTitle\nUS_Gross\nWorldwide_Gross\nProduction_Budget\nRelease_Date\nMPAA_Rating\nRunning_Time_min\nDistributor\nSource\nMajor_Genre\nCreative_Type\nDirector\nRotten_Tomatoes_Rating\nIMDB_Rating\nIMDB_Votes\n\n\n\n\n0\nThe Land Girls\n146083.0\n146083.0\n8000000.0\nJun 12 1998\nR\nNaN\nGramercy\nNone\nNone\nNone\nNone\nNaN\n6.1\n1071.0\n\n\n1\nFirst Love, Last Rites\n10876.0\n10876.0\n300000.0\nAug 07 1998\nR\nNaN\nStrand\nNone\nDrama\nNone\nNone\nNaN\n6.9\n207.0\n\n\n2\nI Married a Strange Person\n203134.0\n203134.0\n250000.0\nAug 28 1998\nNone\nNaN\nLionsgate\nNone\nComedy\nNone\nNone\nNaN\n6.8\n865.0\n\n\n3\nLet's Talk About Sex\n373615.0\n373615.0\n300000.0\nSep 11 1998\nNone\nNaN\nFine Line\nNone\nComedy\nNone\nNone\n13.0\nNaN\nNaN\n\n\n4\nSlam\n1009819.0\n1087521.0\n1000000.0\nOct 09 1998\nR\nNaN\nTrimark\nOriginal Screenplay\nDrama\nContemporary Fiction\nNone\n62.0\n3.4\n165.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n3196\nZack and Miri Make a Porno\n31452765.0\n36851125.0\n24000000.0\nOct 31 2008\nR\n101.0\nWeinstein Co.\nOriginal Screenplay\nComedy\nContemporary Fiction\nKevin Smith\n65.0\n7.0\n55687.0\n\n\n3197\nZodiac\n33080084.0\n83080084.0\n85000000.0\nMar 02 2007\nR\n157.0\nParamount Pictures\nBased on Book/Short Story\nThriller/Suspense\nDramatization\nDavid Fincher\n89.0\nNaN\nNaN\n\n\n3198\nZoom\n11989328.0\n12506188.0\n35000000.0\nAug 11 2006\nPG\nNaN\nSony Pictures\nBased on Comic/Graphic Novel\nAdventure\nSuper Hero\nPeter Hewitt\n3.0\n3.4\n7424.0\n\n\n3199\nThe Legend of Zorro\n45575336.0\n141475336.0\n80000000.0\nOct 28 2005\nPG\n129.0\nSony Pictures\nRemake\nAdventure\nHistorical Fiction\nMartin Campbell\n26.0\n5.7\n21161.0\n\n\n3200\nThe Mask of Zorro\n93828745.0\n233700000.0\n65000000.0\nJul 17 1998\nPG-13\n136.0\nSony Pictures\nRemake\nAdventure\nHistorical Fiction\nMartin Campbell\n82.0\n6.7\n4789.0\n\n\n\n\n3201 rows × 15 columns"
  },
  {
    "objectID": "eda.html#dataset",
    "href": "eda.html#dataset",
    "title": "Exploratory Data Analysis (EDA)",
    "section": "",
    "text": "We will use the movies dataset from vega-datasets, which includes information about thousands of films such as their ratings, genres, duration, and box office revenue.\nLet’s load and preview the dataset:\n\n\nCode\nimport pandas as pd\nimport altair as alt\nfrom vega_datasets import data\n\n# Load dataset\nmovies = data.movies()\n\n# Show first rows\nmovies.head()\n\n\n\n\n\n\n\n\n\nTitle\nUS_Gross\nWorldwide_Gross\nUS_DVD_Sales\nProduction_Budget\nRelease_Date\nMPAA_Rating\nRunning_Time_min\nDistributor\nSource\nMajor_Genre\nCreative_Type\nDirector\nRotten_Tomatoes_Rating\nIMDB_Rating\nIMDB_Votes\n\n\n\n\n0\nThe Land Girls\n146083.0\n146083.0\nNaN\n8000000.0\nJun 12 1998\nR\nNaN\nGramercy\nNone\nNone\nNone\nNone\nNaN\n6.1\n1071.0\n\n\n1\nFirst Love, Last Rites\n10876.0\n10876.0\nNaN\n300000.0\nAug 07 1998\nR\nNaN\nStrand\nNone\nDrama\nNone\nNone\nNaN\n6.9\n207.0\n\n\n2\nI Married a Strange Person\n203134.0\n203134.0\nNaN\n250000.0\nAug 28 1998\nNone\nNaN\nLionsgate\nNone\nComedy\nNone\nNone\nNaN\n6.8\n865.0\n\n\n3\nLet's Talk About Sex\n373615.0\n373615.0\nNaN\n300000.0\nSep 11 1998\nNone\nNaN\nFine Line\nNone\nComedy\nNone\nNone\n13.0\nNaN\nNaN\n\n\n4\nSlam\n1009819.0\n1087521.0\nNaN\n1000000.0\nOct 09 1998\nR\nNaN\nTrimark\nOriginal Screenplay\nDrama\nContemporary Fiction\nNone\n62.0\n3.4\n165.0\n\n\n\n\n\n\n\nNow, let’s examine the shape (number of rows and columns) of the dataset:\n\n\nCode\nmovies.shape\n\n\n(3201, 16)\n\n\nThis tells us how many entries (rows) and features (columns) are present in the dataset."
  },
  {
    "objectID": "eda.html#first-steps",
    "href": "eda.html#first-steps",
    "title": "Exploratory Data Analysis (EDA)",
    "section": "",
    "text": "Before diving deeper into the data, it’s useful to explore some key metadata:\n\n✅ The column names and their data types\n⚠️ The presence of missing values\n📊 Summary statistics for numeric columns\n\n\n\nUnderstanding the structure of the dataset helps us know what type of data we’re dealing with.\n\n\nCode\nmovies.dtypes\n\n\nTitle                      object\nUS_Gross                  float64\nWorldwide_Gross           float64\nUS_DVD_Sales              float64\nProduction_Budget         float64\nRelease_Date               object\nMPAA_Rating                object\nRunning_Time_min          float64\nDistributor                object\nSource                     object\nMajor_Genre                object\nCreative_Type              object\nDirector                   object\nRotten_Tomatoes_Rating    float64\nIMDB_Rating               float64\nIMDB_Votes                float64\ndtype: object\n\n\nWe can also use .info() for a more complete summary, including non-null counts:\n\n\nCode\n# Overview of the dataset\nmovies.info()\n\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 3201 entries, 0 to 3200\nData columns (total 16 columns):\n #   Column                  Non-Null Count  Dtype  \n---  ------                  --------------  -----  \n 0   Title                   3200 non-null   object \n 1   US_Gross                3194 non-null   float64\n 2   Worldwide_Gross         3194 non-null   float64\n 3   US_DVD_Sales            564 non-null    float64\n 4   Production_Budget       3200 non-null   float64\n 5   Release_Date            3201 non-null   object \n 6   MPAA_Rating             2596 non-null   object \n 7   Running_Time_min        1209 non-null   float64\n 8   Distributor             2969 non-null   object \n 9   Source                  2836 non-null   object \n 10  Major_Genre             2926 non-null   object \n 11  Creative_Type           2755 non-null   object \n 12  Director                1870 non-null   object \n 13  Rotten_Tomatoes_Rating  2321 non-null   float64\n 14  IMDB_Rating             2988 non-null   float64\n 15  IMDB_Votes              2988 non-null   float64\ndtypes: float64(8), object(8)\nmemory usage: 400.3+ KB"
  },
  {
    "objectID": "eda.html#missing-values",
    "href": "eda.html#missing-values",
    "title": "Exploratory Data Analysis (EDA)",
    "section": "",
    "text": "Detecting and handling missing values is a critical step in any EDA process. Missing data can bias analysis or break downstream models if not handled properly.\n\nDetect patterns in missingness\nIdentify if some columns are almost entirely null\nDecide whether to drop or impute certain variables\n\n\n\nLet’s start by computing the percentage of missing values in each column:\n\n\nCode\nnan_percent = movies.isna().mean() * 100\nnan_percent_sorted = nan_percent.sort_values(ascending=False).round(2)\nnan_percent_sorted\n\n\nUS_DVD_Sales              82.38\nRunning_Time_min          62.23\nDirector                  41.58\nRotten_Tomatoes_Rating    27.49\nMPAA_Rating               18.90\nCreative_Type             13.93\nSource                    11.40\nMajor_Genre                8.59\nDistributor                7.25\nIMDB_Rating                6.65\nIMDB_Votes                 6.65\nUS_Gross                   0.22\nWorldwide_Gross            0.22\nTitle                      0.03\nProduction_Budget          0.03\nRelease_Date               0.00\ndtype: float64\n\n\n\n\n\nTo visualize missing values with Altair, we need to reshape the data into a long format where each missing value is a row:\n\n\nCode\nmovies_nans = movies.isna().reset_index().melt(\n    id_vars='index',\n    var_name='column',\n    value_name=\"NaN\"\n)\nmovies_nans\n\n\n\n\n\n\n\n\n\nindex\ncolumn\nNaN\n\n\n\n\n0\n0\nTitle\nFalse\n\n\n1\n1\nTitle\nFalse\n\n\n2\n2\nTitle\nFalse\n\n\n3\n3\nTitle\nFalse\n\n\n4\n4\nTitle\nFalse\n\n\n...\n...\n...\n...\n\n\n51211\n3196\nIMDB_Votes\nFalse\n\n\n51212\n3197\nIMDB_Votes\nTrue\n\n\n51213\n3198\nIMDB_Votes\nFalse\n\n\n51214\n3199\nIMDB_Votes\nFalse\n\n\n51215\n3200\nIMDB_Votes\nFalse\n\n\n\n\n51216 rows × 3 columns\n\n\n\n\n\n\nThis heatmap shows where missing values occur across rows and columns. Patterns may indicate:\n\nColumns with consistently missing values\nEntire rows with large gaps\nCorrelated missingness between variables\n\nTo avoid limitations in the number of rows rendered by Altair, we disable the max rows warning:\n\n\nCode\nalt.data_transformers.disable_max_rows()\n\n\nDataTransformerRegistry.enable('default')\n\n\nNow we can create the heatmap:\n\n\nCode\nalt.Chart(movies_nans).mark_rect().encode(\n    alt.X('index:O'),\n    alt.Y('column'),\n    alt.Color('NaN')\n).properties(\n    width=1000\n)\n\n\n\n\n\n\n\nThis plot can help identify columns or rows with critical data issues.\n\n\n\nIn many real-world cases, we may decide to remove columns that have too many missing values. Let’s set a threshold of 70%:\n\n\nCode\nthreshold_nan = 70 # in percent\ncols_to_drop = nan_percent[nan_percent&gt;threshold_nan].index\ncols_to_drop\n\n\nIndex(['US_DVD_Sales'], dtype='object')\n\n\nThese columns have more than 70% missing values and may not be useful for analysis."
  },
  {
    "objectID": "eda.html#cleaned-dataset",
    "href": "eda.html#cleaned-dataset",
    "title": "Exploratory Data Analysis (EDA)",
    "section": "",
    "text": "Finally, we drop the selected columns and inspect the updated dataset:\n\n\nCode\nmovies_cleaned = movies.drop(columns=cols_to_drop)\nmovies_cleaned\n\n\n\n\n\n\n\n\n\nTitle\nUS_Gross\nWorldwide_Gross\nProduction_Budget\nRelease_Date\nMPAA_Rating\nRunning_Time_min\nDistributor\nSource\nMajor_Genre\nCreative_Type\nDirector\nRotten_Tomatoes_Rating\nIMDB_Rating\nIMDB_Votes\n\n\n\n\n0\nThe Land Girls\n146083.0\n146083.0\n8000000.0\nJun 12 1998\nR\nNaN\nGramercy\nNone\nNone\nNone\nNone\nNaN\n6.1\n1071.0\n\n\n1\nFirst Love, Last Rites\n10876.0\n10876.0\n300000.0\nAug 07 1998\nR\nNaN\nStrand\nNone\nDrama\nNone\nNone\nNaN\n6.9\n207.0\n\n\n2\nI Married a Strange Person\n203134.0\n203134.0\n250000.0\nAug 28 1998\nNone\nNaN\nLionsgate\nNone\nComedy\nNone\nNone\nNaN\n6.8\n865.0\n\n\n3\nLet's Talk About Sex\n373615.0\n373615.0\n300000.0\nSep 11 1998\nNone\nNaN\nFine Line\nNone\nComedy\nNone\nNone\n13.0\nNaN\nNaN\n\n\n4\nSlam\n1009819.0\n1087521.0\n1000000.0\nOct 09 1998\nR\nNaN\nTrimark\nOriginal Screenplay\nDrama\nContemporary Fiction\nNone\n62.0\n3.4\n165.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n3196\nZack and Miri Make a Porno\n31452765.0\n36851125.0\n24000000.0\nOct 31 2008\nR\n101.0\nWeinstein Co.\nOriginal Screenplay\nComedy\nContemporary Fiction\nKevin Smith\n65.0\n7.0\n55687.0\n\n\n3197\nZodiac\n33080084.0\n83080084.0\n85000000.0\nMar 02 2007\nR\n157.0\nParamount Pictures\nBased on Book/Short Story\nThriller/Suspense\nDramatization\nDavid Fincher\n89.0\nNaN\nNaN\n\n\n3198\nZoom\n11989328.0\n12506188.0\n35000000.0\nAug 11 2006\nPG\nNaN\nSony Pictures\nBased on Comic/Graphic Novel\nAdventure\nSuper Hero\nPeter Hewitt\n3.0\n3.4\n7424.0\n\n\n3199\nThe Legend of Zorro\n45575336.0\n141475336.0\n80000000.0\nOct 28 2005\nPG\n129.0\nSony Pictures\nRemake\nAdventure\nHistorical Fiction\nMartin Campbell\n26.0\n5.7\n21161.0\n\n\n3200\nThe Mask of Zorro\n93828745.0\n233700000.0\n65000000.0\nJul 17 1998\nPG-13\n136.0\nSony Pictures\nRemake\nAdventure\nHistorical Fiction\nMartin Campbell\n82.0\n6.7\n4789.0\n\n\n\n\n3201 rows × 15 columns"
  },
  {
    "objectID": "eda.html#univariate-analysis-quantitative",
    "href": "eda.html#univariate-analysis-quantitative",
    "title": "Exploratory Data Analysis (EDA)",
    "section": "2.1 Univariate Analysis: Quantitative",
    "text": "2.1 Univariate Analysis: Quantitative\nA univariate analysis focuses on examining a single numeric variable to understand its distribution, shape, central tendency, and spread. One of the most common tools for this is the histogram.\nIn this case, we’ll explore the distribution of the movie runtime (Running_Time_min).\n\n2.1.1 Basic Histogram\nWe start by creating a histogram to visualize the distribution of running times:\n\n\nCode\nalt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('Running_Time_min',bin=alt.Bin(maxbins=30)),\n    alt.Y('count()')\n).properties(\n    title='Histogram of Movie Runtimes (30 bins)'\n)\n\n\n\n\n\n\n\nThis chart shows how many movies fall into each time interval (bin). However, histograms can look quite different depending on the number and size of bins used.\n\n\n2.1.2 Effect of Bin Size\nLet’s compare how the histogram shape changes with different bin sizes:\n\n\nCode\nhistogram_1 = alt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('Running_Time_min',bin=alt.Bin(maxbins=8)),\n    alt.Y('count()')\n)\n\nhistogram_2 = alt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('Running_Time_min',bin=alt.Bin(maxbins=10)),\n    alt.Y('count()')\n)\n\nhistogram_1 | histogram_2\n\n\n\n\n\n\n\nEven though both plots use the same data, the choice of bin size changes the visual interpretation. A small number of bins may hide details, while too many bins can make it harder to spot trends.\n\n\n2.1.3 Density plots, or Kernel Density Estimate (KDE)\nDensity plots offer a smoothed alternative to histograms. Instead of using rectangular bins to count data points, they estimate the probability density function by placing bell-shaped curves (kernels) at each observation and summing them.\nThis approach helps reduce the visual noise and jaggedness that can occur in histograms and gives a clearer picture of the underlying distribution.\n\n\nCode\nalt.Chart(movies_cleaned).transform_density(\n    'Running_Time_min',\n    as_=['Running_Time_min','density'],\n).mark_area().encode(\n    alt.X('Running_Time_min'),\n    alt.Y('density:Q')\n).properties(\n    title=\"Movies runtime\"\n)\n\n\n\n\n\n\n\n\n\n2.1.4 Grouped Density plot\nWe can also compare distributions across groups by splitting the KDE by a categorical variable using the groupby parameter. This helps us see how the distribution differs between categories, such as genres.\n\n\nCode\nselection = alt.selection_single(fields=['Major_Genre'], bind='legend')\n\nalt.Chart(movies_cleaned).transform_density(\n    'Running_Time_min',\n    groupby=['Major_Genre'],\n    as_=['Running_Time_min', 'density'],\n).mark_area(opacity=0.5).encode(\n    alt.X('Running_Time_min'),\n    alt.Y('density:Q', stack=None),\n    alt.Color('Major_Genre'),\n    opacity=alt.condition(selection, \n        alt.value(1), \n        alt.value(0.05)\n    )\n).add_selection(\n    selection\n).properties(\n    title=\"Movies Runtime by Genre (Interactive Filter)\"\n).interactive()\n\n\n\n\n\n\n\nThe transparency (opacity=0.5) allows us to observe overlapping distributions and ensures that small density areas are not completely hidden behind larger ones.\nFrom this plot, we can observe, for example, that Drama movies have runtimes nearly as long as the longest Adventure movies, even though their overall distributions differ."
  },
  {
    "objectID": "eda.html#bivariate-analysis-categorical-vs-quantitative",
    "href": "eda.html#bivariate-analysis-categorical-vs-quantitative",
    "title": "Exploratory Data Analysis (EDA)",
    "section": "2.2 Bivariate Analysis: Categorical vs Quantitative",
    "text": "2.2 Bivariate Analysis: Categorical vs Quantitative\nBivariate analysis examines the relationship between two variables. In this case, we focus on one categorical variable (e.g., genre) and one quantitative variable (e.g., revenue), which is a very common scenario in exploratory data analysis.\nThis type of analysis is useful to: - Compare average or median values across categories. - Detect outliers or high-variance groups. - Understand distributional differences across categories.\nBelow are several effective visualizations for this analysis.\n\n2.2.1 Basic Barchart\nBar charts are effective for comparing aggregated values (like the mean) across different groups. However, they hide the distribution and variation within each group.\n\n\nCode\nalt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('mean(Worldwide_Gross)'),\n    alt.Y(\"Major_Genre\")\n).properties(\n    title=\"Average Worldwide Gross by Genre\"\n)\n\n\n\n\n\n\n\nThis bar chart shows the mean Worldwide Gross per genre. It is useful for identifying which genres are more profitable on average, but does not show how spread out the data is.\n\n\n2.2.2 Tick Plot\nTo visualize individual data points, we use a tick plot. This helps uncover variability within genres and detect outliers.\n\n\nCode\nalt.Chart(movies_cleaned).mark_tick().encode(\n    alt.X('Worldwide_Gross'),\n    alt.Y(\"Major_Genre\"),\n    alt.Tooltip('Title:N')\n).properties(\n    title=\"Individual Gross per Movie by Genre\"\n)\n\n\n\n\n\n\n\n\n\n2.2.3 Heatmaps\nHeatmaps can summarize the frequency of data points across both axes (quantitative and categorical) using color intensity. It’s particularly useful for spotting patterns without getting overwhelmed by individual points.\n\n\nCode\nalt.Chart(movies_cleaned).mark_rect().encode(\n    alt.X('Worldwide_Gross',bin=alt.Bin(maxbins=100)),\n    alt.Y(\"Major_Genre\"),\n    alt.Color('count()'),\n    alt.Tooltip('count()')\n).properties(\n    title=\"Heatmap of Movie Counts by Gross and Genre\"\n)\n\n\n\n\n\n\n\nThis heatmap shows how frequently movies from each genre fall into different revenue ranges.\n\n\n2.2.4 Boxplot\nBoxplots are useful for comparing distributions across categories and identifying outliers. Boxplots summarize a distribution using five statistics:\n\nMedian (Q2)\nFirst Quartile (Q1)\nThird Quartile (Q3)\nLower Whisker (Q1 - 1.5 × IQR)\nUpper Whisker (Q3 + 1.5 × IQR)\n\n\n\nCode\nalt.Chart(movies_cleaned).mark_boxplot().encode(\n    alt.X('Worldwide_Gross'),\n    alt.Y(\"Major_Genre\")\n).properties(\n    title=\"Boxplot of Worldwide Gross by Genre\"\n)\n\n\n\n\n\n\n\n\n\n2.2.5 Side-by-side: Boxplot and Bar Chart\nTo contrast aggregated values (bar chart) with the full distribution (boxplot), we can display them together:\n\n\nCode\nbar = alt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('mean(Worldwide_Gross)'),\n    alt.Y(\"Major_Genre\")\n)\n\nbox = alt.Chart(movies_cleaned).mark_boxplot().encode(\n    alt.X('mean(Worldwide_Gross)'),\n    alt.Y(\"Major_Genre\")\n)\n\nbox | bar\n\n\n\n\n\n\n\nThis comparison reveals whether the mean is a good representative of the genre, or whether the data is skewed or contains outliers that affect the average"
  },
  {
    "objectID": "eda.html#bivariate-analysis-quantitative-vs-quantitative",
    "href": "eda.html#bivariate-analysis-quantitative-vs-quantitative",
    "title": "Exploratory Data Analysis (EDA)",
    "section": "2.3 Bivariate Analysis: Quantitative vs Quantitative",
    "text": "2.3 Bivariate Analysis: Quantitative vs Quantitative\nWhen analyzing two quantitative (numerical) variables simultaneously, we aim to discover possible relationships, trends, or correlations. This type of bivariate analysis can reveal whether increases in one variable are associated with increases or decreases in another (positive or negative correlation), or if there’s no relationship at all. The most common and intuitive visualization for this is the scatterplot.\n\n2.3.1 Scatterplots\nScatter plots are effective visualizations for exploring two-dimensional distributions, allowing us to identify patterns, trends, clusters, or outliers.\nLet’s start by visualizing how movies are rated across two popular online platforms:\n\nIMDb\n\nRotten Tomatoes\n\nAre movies rated similarly on different platforms?\n\n\nCode\nalt.Chart(movies_cleaned).mark_point().encode(\n    alt.X('IMDB_Rating'),\n    alt.Y('Rotten_Tomatoes_Rating')\n).properties(\n    title=\"IMDB vs Rotten Tomatoes Ratings\"\n)\n\n\n\n\n\n\n\n\n\n2.3.2 Scatterplot Saturation\nScatterplots can become saturated when too many points overlap in a small area of the chart, making it difficult to distinguish dense regions from sparse ones. For example, when plotting financial variables like production budget versus worldwide gross:\n\n\nCode\nsaturated = alt.Chart(movies_cleaned).mark_point().encode(\n    alt.X('Production_Budget'),\n    alt.Y('Worldwide_Gross')\n).properties(\n    title=\"Saturated Scatterplot: Budget vs Gross\"\n)\nsaturated\n\n\n\n\n\n\n\n\n\n2.3.3 Using Binned Heatmap to Reduce Saturation\nTo address saturation, we can bin both variables and use a heatmap where the color intensity represents the number of movies that fall into each rectangular region of the grid. This makes dense areas more interpretable\n\n\nCode\nheatmap_scatter = alt.Chart(movies_cleaned).mark_rect().encode(\n    alt.X('Production_Budget', bin=alt.Bin(maxbins=60)),\n    alt.Y('Worldwide_Gross', bin=alt.Bin(maxbins=60)),\n    alt.Color('count()'),\n    alt.Tooltip('count()')\n).properties(\n    title=\"Binned Heatmap: Budget vs Gross\"\n)\nheatmap_scatter\n\n\n\n\n\n\n\n\n\n2.3.4 Side-by-side Comparison\nCompare the raw scatterplot with the heatmap representation:\n\n\nCode\nsaturated | heatmap_scatter"
  },
  {
    "objectID": "eda.html#bivariate-analysis-categorical-vs-categorical",
    "href": "eda.html#bivariate-analysis-categorical-vs-categorical",
    "title": "Exploratory Data Analysis (EDA)",
    "section": "2.4 Bivariate Analysis: Categorical vs Categorical",
    "text": "2.4 Bivariate Analysis: Categorical vs Categorical\nWhen working with two categorical variables, bivariate analysis helps us understand how categories from one variable relate or are distributed across the other. For example, we might want to know how different movie genres are rated according to the MPAA rating system. Visualization techniques like grouped bar charts and faceted plots can reveal patterns, associations, or class imbalances.\n\n2.4.1 Basic Faceted Bar Chart\nWe begin by exploring how movies are rated (MPAA_Rating) across different genres (Major_Genre). A faceted bar chart allows us to visualize this relationship by plotting a bar chart per genre, helping to identify genre-specific rating distributions.\n\n\nCode\nalt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('count()'),\n    alt.Y('MPAA_Rating'),\n    alt.Color('MPAA_Rating')\n).facet(\n    'Major_Genre'\n)\n\n\n\n\n\n\n\n\n\n2.4.2 Vertical Faceting for Alignment\nFaceting horizontally can make comparisons across genres harder when the x-axis is misaligned. By specifying columns=1, we lay out the facets vertically, making it easier to compare counts across genres.\n\n\nCode\nalt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('count()'),\n    alt.Y('MPAA_Rating'),\n    alt.Color('MPAA_Rating')\n).facet(\n    'Major_Genre',\n    columns=1\n)\n\n\n\n\n\n\n\n\n\n2.4.3 Dependent vs Independent Axis Scaling\nBy default, facet plots share the same x-axis scale (dependent scale), which allows for easier comparison across panels. However, when the number of observations varies greatly between genres, this shared scale can compress some charts.\nWe can instead use independent x-axis scaling for each facet. This highlights the relative distribution within each genre.\n\n\nCode\nshared_scale = alt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('count()'),\n    alt.Y('MPAA_Rating'),\n    alt.Color('MPAA_Rating')\n).facet(\n    'Major_Genre',\n    columns=4\n)\n\nindependent_scale = alt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X('count()'),\n    alt.Y('MPAA_Rating'),\n    alt.Color('MPAA_Rating')\n).facet(\n    'Major_Genre',\n    columns=4\n).resolve_scale(x='independent')\n\nshared_scale | independent_scale\n\n\n\n\n\n\n\nThe left panel (shared scale) makes absolute comparisons between genres, while the right panel (independent scale) makes within-genre comparisons more readable.\n\n\n2.4.4 Heatmaps\nHeatmaps are effective for visualizing the relationship between two categorical variables when the goal is to display counts or frequency of occurrences. They map the number of observations to color, providing an intuitive view of which category pairs are most or least common.\nWe can enhance this basic representation by also using marker size, combining both color intensity and circle area to represent counts more effectively. This dual encoding can improve interpretation, especially when printed in grayscale or when there are subtle color differences.\n\n\nCode\nheatmap_color = alt.Chart(movies_cleaned).mark_rect().encode(\n    alt.X('MPAA_Rating'),\n    alt.Y('Major_Genre', sort='color'),\n    alt.Color('count()')\n).properties(\n    title=\"Heatmap with Color (Count of Movies)\"\n)\n\nheatmap_size = alt.Chart(movies_cleaned).mark_circle().encode(\n    alt.X('MPAA_Rating'),\n    alt.Y('Major_Genre', sort='color'),\n    alt.Color('count()'),\n    alt.Size('count()')\n).properties(\n    title=\"Heatmap with Color + Size (Count of Movies)\"\n)\n\nheatmap_color | heatmap_size"
  },
  {
    "objectID": "eda.html#multivariate-analysis",
    "href": "eda.html#multivariate-analysis",
    "title": "Exploratory Data Analysis (EDA)",
    "section": "2.5 Multivariate Analysis",
    "text": "2.5 Multivariate Analysis\nMultivariate analysis helps us understand the interactions and relationships among multiple variables simultaneously. In the context of numerical features, it is useful to explore pairwise distributions, correlations, and detect potential clusters or anomalies.\nWhen the number of variables is large, repeated charts such as histograms or scatter plot matrices help us summarize patterns efficiently and consistently across all numerical dimensions.\n\n2.5.1 Repeated Histograms for Numerical Columns\nWe first identify and isolate all numerical columns from the dataset. Then we repeat a histogram for each of these columns to understand the individual distributions. This overview is helpful to detect skewness, outliers, or binning decisions that affect how data is grouped visually.\n\n\nCode\n# Select only numerical columns\nnumerical_columns = movies_cleaned.select_dtypes('number').columns.tolist()\n\n\n\n\nCode\nalt.Chart(movies_cleaned).mark_bar().encode(\n    alt.X(alt.repeat(),type='quantitative',bin=alt.Bin(maxbins=30)),\n    alt.Y('count()')\n).properties(\n    width=150,\n    height=150\n).repeat(\n    numerical_columns,\n    columns=4\n)\n\n\n\n\n\n\n\n\n\n2.5.2 Scatter Plot Matrix (Pairplot)\nA scatter plot matrix shows the pairwise relationships between all numerical variables. This is a common exploratory tool to detect:\n\nCorrelations between variables\nOutliers or clusters\nRelationships useful for prediction models (e.g., to predict rating or budget)\n\nWe focus especially on the plots below the diagonal, as they are not duplicated.\n\n\nCode\nalt.Chart(movies_cleaned).mark_point().encode(\n    alt.X(alt.repeat('column'),type='quantitative'),\n    alt.Y(alt.repeat('row'),type='quantitative'),\n    alt.Tooltip('Title:N')\n).properties(\n    width=100,\n    height=100\n).repeat(\n    column=numerical_columns,\n    row=numerical_columns\n)\n\n\n\n\n\n\n\n\n\n2.5.3 Heatmap Matrix\nWhen scatter plots become too saturated (many overlapping points), heatmaps offer a better alternative by binning the numeric values and encoding the count in color intensity.\n\n\nCode\nalt.Chart(movies_cleaned).mark_rect().encode(\n    alt.X(alt.repeat('column'),type='quantitative',bin=alt.Bin(maxbins=30)),\n    alt.Y(alt.repeat('row'),type='quantitative',bin=alt.Bin(maxbins=30)),\n    alt.Color('count()'),\n    alt.Tooltip('count()')\n).properties(\n    width=100,\n    height=100\n).repeat(\n    column=numerical_columns,\n    row=numerical_columns\n).resolve_scale(\n    color='independent'\n)\n\n\n\n\n\n\n\nTo gain deeper insights into the dataset, it’s important to analyze how numerical variables behave across different categories. This type of multivariate analysis allows us to:\n\nCompare distributions across categories\nDetect outliers within categories\nObserve central tendency (median, quartiles) and spread (range, IQR)\n\nBoxplots are particularly effective for this purpose. In the following visualizations, we explore these relationships by repeating plots across combinations of categorical and numerical features.\n\n\n2.5.4 Filter Categorical Columns\nFirst, we select the relevant categorical columns, excluding identifiers and text-heavy variables like movie titles or director names.\n\n\nCode\ncategorical_columns =  movies_cleaned.select_dtypes('object').columns.to_list()\n\ncategorical_columns_remove = ['Title','Release_Date','Distributor','Director']\n\ncategorical_filtered = [col for col in categorical_columns if col not in categorical_columns_remove]\n\n\n\n\n2.5.5 Repeated Boxplots: Categorical vs Numerical\nWe repeat boxplots using combinations of categorical (rows) and numerical (columns) features. This matrix layout gives a clear visual overview of how numerical values are distributed within each category.\n\n\nCode\nalt.Chart(movies_cleaned).mark_boxplot().encode(\n    alt.X(alt.repeat('column'),type='quantitative'),\n    alt.Y(alt.repeat('row'),type='nominal'),\n    alt.Size('count()')\n).properties(\n    width=200,\n    height=200\n).repeat(\n    column=numerical_columns,\n    row=categorical_filtered\n)\n\n\n\n\n\n\n\n\n\n2.5.6 Faceted Boxplots\nFor more focused analysis, we can facet the boxplots using a specific categorical variable like MPAA_Rating, and repeat the chart by different categorical rows. This lets us keep the numerical axis fixed while comparing how categories vary across different classes (e.g., movie ratings).\n\n\nCode\nalt.Chart(movies_cleaned).mark_boxplot().encode(\n    alt.X('Running_Time_min', type='quantitative'),\n    alt.Y(alt.repeat('row'),type='nominal'),\n    alt.Size('count()'),\n    alt.Tooltip('Title:N')\n).properties(\n    width=100,\n    height=100\n).facet(\n    column='MPAA_Rating'\n).repeat(\n    row=categorical_filtered\n)"
  },
  {
    "objectID": "regresion_hogares.html",
    "href": "regresion_hogares.html",
    "title": "Regresión - Predicción de Deciles Socioeconómicos",
    "section": "",
    "text": "Este documento presenta un modelo de regresión lineal para predecir el decil socioeconómico de hogares ecuatorianos utilizando datos de la Encuesta de Condiciones de Vida 2018.\nObjetivo: Desarrollar un modelo predictivo que estime el nivel socioeconómico basado en características del hogar y ubicación geográfica.\n\n\n\n\n\nCode\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split, learning_curve\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.metrics import mean_squared_error, r2_score\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Configurar matplotlib\nplt.style.use('default')\nsns.set_palette(\"husl\")\n\nprint(\"=== SISTEMA DE REGRESIÓN - DECILES SOCIOECONÓMICOS ===\")\n\n\n=== SISTEMA DE REGRESIÓN - DECILES SOCIOECONÓMICOS ===\n\n\n\n\nCode\n# Cargar datos principales\ndf = pd.read_csv('DATOS_REGRESSION/hogares_rs18.csv', encoding='utf-8')\n\nprint(f\"Datos cargados: {df.shape[0]} filas, {df.shape[1]} columnas\")\nprint(f\"Columnas disponibles: {list(df.columns)}\")\n\n\nDatos cargados: 2565433 filas, 29 columnas\nColumnas disponibles: ['s1_id06_cod', 's1_id06_des', 's1_id05_cod', 's1_id05_des', 's1_id04_cod', 's1_id04_des', 's1_id03', 's3_vi02', 's3_vi05_est', 's3_vi04_est', 's3_vi03_est', 's3_vi05', 's3_vi04', 's3_vi03', 's3_vi01', 's4_ho08', 's4_ho17', 's4_ho16', 's4_ho06', 's4_ho01', 's4_ho19', 's4_ho12', 's4_ho21', 's4_ho22', 'decil', 'tipo_pob_rs18', 'tot_hogares', 'tot_nucleos', 'tot_personas']\n\n\n\n\nCode\n# Diccionario de variables conocidas\nvariable_mapping = {\n    'decil': 'Decil socioeconómico del hogar (1=más pobre, 10=más rico)',\n    'tipo_pob_rs18': 'Tipo de pobreza del hogar',\n    'tot_hogares': 'Total de hogares en el área',\n    'tot_nucleos': 'Total de núcleos familiares',\n    'tot_personas': 'Total de personas en el hogar',\n    's1_id03': 'Código de área (1=Urbano, 0=Rural)',\n    's3_vi01': 'Tipo de vivienda',\n    's3_vi03': 'Material predominante del piso',\n    's3_vi04': 'Material predominante del techo',\n    's3_vi05': 'Material predominante de las paredes',\n    's4_ho01': 'Procedencia principal del agua',\n    's4_ho06': 'Tipo de servicio eléctrico',\n    's4_ho08': 'Tipo de servicio higiénico',\n    's4_ho12': 'Servicio telefónico convencional',\n    's4_ho16': 'Eliminación de la basura',\n    's4_ho17': 'Combustible para cocinar'\n}\n\nprint(\"=== DICCIONARIO DE VARIABLES ===\")\nfor var, desc in variable_mapping.items():\n    print(f\"{var}: {desc}\")\n\n\n=== DICCIONARIO DE VARIABLES ===\ndecil: Decil socioeconómico del hogar (1=más pobre, 10=más rico)\ntipo_pob_rs18: Tipo de pobreza del hogar\ntot_hogares: Total de hogares en el área\ntot_nucleos: Total de núcleos familiares\ntot_personas: Total de personas en el hogar\ns1_id03: Código de área (1=Urbano, 0=Rural)\ns3_vi01: Tipo de vivienda\ns3_vi03: Material predominante del piso\ns3_vi04: Material predominante del techo\ns3_vi05: Material predominante de las paredes\ns4_ho01: Procedencia principal del agua\ns4_ho06: Tipo de servicio eléctrico\ns4_ho08: Tipo de servicio higiénico\ns4_ho12: Servicio telefónico convencional\ns4_ho16: Eliminación de la basura\ns4_ho17: Combustible para cocinar\n\n\n\n\n\n\n\nCode\nprint(\"=== EXPLORACIÓN INICIAL ===\")\nprint(f\"Forma del dataset: {df.shape}\")\nprint(f\"\\nPrimeras 5 filas:\")\ndf.head()\n\n\n=== EXPLORACIÓN INICIAL ===\nForma del dataset: (2565433, 29)\n\nPrimeras 5 filas:\n\n\n\n\n\n\n\n\n\ns1_id06_cod\ns1_id06_des\ns1_id05_cod\ns1_id05_des\ns1_id04_cod\ns1_id04_des\ns1_id03\ns3_vi02\ns3_vi05_est\ns3_vi04_est\n...\ns4_ho01\ns4_ho19\ns4_ho12\ns4_ho21\ns4_ho22\ndecil\ntipo_pob_rs18\ntot_hogares\ntot_nucleos\ntot_personas\n\n\n\n\n0\n10150\nCUENCA\n101\nCUENCA\n1\nAZUAY\n1\n1\n1\n1\n...\n1\n1\n1\n1\n1\n8\nNo pobre\n2\n3\n9\n\n\n1\n10150\nCUENCA\n101\nCUENCA\n1\nAZUAY\n1\n1\n1\n1\n...\n1\n1\n1\n1\n1\n9\nNo pobre\n5\n5\n22\n\n\n2\n10150\nCUENCA\n101\nCUENCA\n1\nAZUAY\n1\n1\n1\n1\n...\n1\n1\n1\n1\n1\n10\nNo pobre\n1\n1\n2\n\n\n3\n10150\nCUENCA\n101\nCUENCA\n1\nAZUAY\n1\n1\n1\n1\n...\n1\n1\n1\n1\n2\n4\nNo pobre\n1\n2\n7\n\n\n4\n10150\nCUENCA\n101\nCUENCA\n1\nAZUAY\n1\n1\n1\n1\n...\n1\n1\n1\n1\n2\n5\nNo pobre\n2\n3\n12\n\n\n\n\n5 rows × 29 columns\n\n\n\n\n\nCode\n# Estadísticas descriptivas de variables clave\nprint(\"=== ESTADÍSTICAS DESCRIPTIVAS ===\")\nkey_columns = ['decil', 'tot_hogares', 'tot_personas', 's3_vi01', 'tipo_pob_rs18']\nexisting_cols = [col for col in key_columns if col in df.columns]\nif existing_cols:\n    df[existing_cols].describe()\nelse:\n    print(\"No se encontraron las columnas esperadas\")\n\n\n=== ESTADÍSTICAS DESCRIPTIVAS ===\n\n\n\n\nCode\n# Verificar valores faltantes\nprint(\"=== VALORES FALTANTES ===\")\nmissing_data = df.isnull().sum()\nmissing_percent = (missing_data / len(df)) * 100\nmissing_df = pd.DataFrame({\n    'Columna': missing_data.index,\n    'Valores_Faltantes': missing_data.values,\n    'Porcentaje': missing_percent.values\n}).sort_values('Valores_Faltantes', ascending=False)\n\nprint(missing_df.head(10))\n\n\n=== VALORES FALTANTES ===\n          Columna  Valores_Faltantes  Porcentaje\n0     s1_id06_cod                  0         0.0\n15        s4_ho08                  0         0.0\n27    tot_nucleos                  0         0.0\n26    tot_hogares                  0         0.0\n25  tipo_pob_rs18                  0         0.0\n24          decil                  0         0.0\n23        s4_ho22                  0         0.0\n22        s4_ho21                  0         0.0\n21        s4_ho12                  0         0.0\n20        s4_ho19                  0         0.0\n\n\n\n\n\n\n\nCode\nprint(\"=== DEFINIENDO VARIABLE OBJETIVO ===\")\n# Variable objetivo: decil socioeconómico\ntarget_col = 'decil'\nif target_col in df.columns:\n    print(f\"Variable objetivo: {target_col}\")\n    print(f\"Distribución de deciles:\")\n    print(df[target_col].value_counts().sort_index())\n    \n    # Visualizar distribución\n    plt.figure(figsize=(10, 6))\n    df[target_col].hist(bins=10, edgecolor='black', alpha=0.7, color='skyblue')\n    plt.title('Distribución de Deciles Socioeconómicos', fontsize=14, fontweight='bold')\n    plt.xlabel('Decil')\n    plt.ylabel('Frecuencia')\n    plt.grid(alpha=0.3)\n    plt.show()\nelse:\n    print(f\"ERROR: Columna {target_col} no encontrada\")\n\n\n=== DEFINIENDO VARIABLE OBJETIVO ===\nVariable objetivo: decil\nDistribución de deciles:\n1     382465\n2     499175\n3     403812\n4     334334\n5     263928\n6     228965\n7     192018\n8     143883\n9      86887\n10     29966\nName: decil, dtype: int64\n\n\n\n\n\n\n\n\n\n\n\nCode\nprint(\"=== SELECCIONANDO Y CLASIFICANDO FEATURES ===\")\n# Primero ver todas las columnas disponibles\nprint(\"Columnas disponibles en el dataset:\")\nprint(list(df.columns))\n\n# Clasificar features por tipo de datos\nnumerical_features = [\n    'tot_hogares',   # Total de hogares\n    'tot_nucleos',   # Total de núcleos familiares\n    'tot_personas'   # Total de personas\n]\n\ncategorical_features = [\n    's3_vi01',       # Tipo de vivienda\n    's3_vi03',       # Material de piso\n    's3_vi04',       # Material de techo  \n    's3_vi05',       # Material de paredes\n    's4_ho01',       # Procedencia del agua\n    's4_ho06',       # Servicio eléctrico\n    's4_ho08',       # Servicio higiénico\n    's4_ho12',       # Teléfono convencional\n    's4_ho16',       # Eliminación de basura\n    's4_ho17'        # Combustible para cocinar\n]\n\nall_features = numerical_features + categorical_features\n\n# Verificar qué columnas existen\navailable_numerical = [col for col in numerical_features if col in df.columns]\navailable_categorical = [col for col in categorical_features if col in df.columns]\navailable_features = available_numerical + available_categorical\n\nprint(f\"Features numéricas disponibles: {available_numerical}\")\nprint(f\"Features categóricas disponibles: {available_categorical}\")\nprint(f\"Total features: {len(available_features)}\")\n\n\n=== SELECCIONANDO Y CLASIFICANDO FEATURES ===\nColumnas disponibles en el dataset:\n['s1_id06_cod', 's1_id06_des', 's1_id05_cod', 's1_id05_des', 's1_id04_cod', 's1_id04_des', 's1_id03', 's3_vi02', 's3_vi05_est', 's3_vi04_est', 's3_vi03_est', 's3_vi05', 's3_vi04', 's3_vi03', 's3_vi01', 's4_ho08', 's4_ho17', 's4_ho16', 's4_ho06', 's4_ho01', 's4_ho19', 's4_ho12', 's4_ho21', 's4_ho22', 'decil', 'tipo_pob_rs18', 'tot_hogares', 'tot_nucleos', 'tot_personas']\nFeatures numéricas disponibles: ['tot_hogares', 'tot_nucleos', 'tot_personas']\nFeatures categóricas disponibles: ['s3_vi01', 's3_vi03', 's3_vi04', 's3_vi05', 's4_ho01', 's4_ho06', 's4_ho08', 's4_ho12', 's4_ho16', 's4_ho17']\nTotal features: 13\n\n\n\n\n\n\n\nCode\nprint(\"=== PREPARANDO DATOS PARA EL MODELO ===\")\n# Crear dataset limpio\nmodel_data = df[available_features + [target_col]].copy()\n\n# Eliminar filas con valores faltantes\ninitial_rows = len(model_data)\nmodel_data = model_data.dropna()\nfinal_rows = len(model_data)\n\nprint(f\"Filas iniciales: {initial_rows}\")\nprint(f\"Filas después de limpiar: {final_rows}\")\nprint(f\"Filas eliminadas: {initial_rows - final_rows}\")\n\n# Separar features y target\nX = model_data[available_features]\ny = model_data[target_col]\n\nprint(f\"Forma final de X: {X.shape}\")\nprint(f\"Forma final de y: {y.shape}\")\nprint(f\"Features numéricas: {available_numerical}\")\nprint(f\"Features categóricas: {available_categorical}\")\n\n\n=== PREPARANDO DATOS PARA EL MODELO ===\nFilas iniciales: 2565433\nFilas después de limpiar: 2565433\nFilas eliminadas: 0\nForma final de X: (2565433, 13)\nForma final de y: (2565433,)\nFeatures numéricas: ['tot_hogares', 'tot_nucleos', 'tot_personas']\nFeatures categóricas: ['s3_vi01', 's3_vi03', 's3_vi04', 's3_vi05', 's4_ho01', 's4_ho06', 's4_ho08', 's4_ho12', 's4_ho16', 's4_ho17']\n\n\n\n\nCode\n# Estadísticas de las features\nprint(\"=== ESTADÍSTICAS DE FEATURES ===\")\nif len(available_features) &gt; 0:\n    X.describe()\nelse:\n    print(\"No hay features disponibles para mostrar estadísticas\")\n\n\n=== ESTADÍSTICAS DE FEATURES ===\n\n\n\n\n\n\n\nCode\nprint(\"=== DIVIDIENDO DATOS ===\")\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42\n)\n\nprint(f\"Entrenamiento: {X_train.shape[0]} muestras\")\nprint(f\"Prueba: {X_test.shape[0]} muestras\")\nprint(f\"Estadísticas del target en entrenamiento:\")\nprint(f\"Media: {y_train.mean():.2f}\")\nprint(f\"Desviación estándar: {y_train.std():.2f}\")\n\n\n=== DIVIDIENDO DATOS ===\nEntrenamiento: 2052346 muestras\nPrueba: 513087 muestras\nEstadísticas del target en entrenamiento:\nMedia: 3.98\nDesviación estándar: 2.36\n\n\n\n\n\n\n\nCode\nprint(\"=== CREANDO PIPELINE DE REGRESIÓN ===\")\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.preprocessing import OneHotEncoder\n\n# Crear pipeline de preprocesamiento correcto\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('num', StandardScaler(), available_numerical),\n        ('cat', OneHotEncoder(drop='first', handle_unknown='ignore'), available_categorical)\n    ])\n\n# Pipeline completo con preprocesamiento adecuado\npipeline = Pipeline([\n    ('preprocessor', preprocessor),\n    ('regressor', LinearRegression())\n])\n\n# Entrenar modelo\nprint(\"Entrenando modelo LinearRegression con preprocesamiento correcto...\")\nprint(f\"Variables numéricas: {available_numerical}\")\nprint(f\"Variables categóricas: {available_categorical}\")\npipeline.fit(X_train, y_train)\nprint(\"✓ Modelo entrenado exitosamente\")\n\n\n=== CREANDO PIPELINE DE REGRESIÓN ===\nEntrenando modelo LinearRegression con preprocesamiento correcto...\nVariables numéricas: ['tot_hogares', 'tot_nucleos', 'tot_personas']\nVariables categóricas: ['s3_vi01', 's3_vi03', 's3_vi04', 's3_vi05', 's4_ho01', 's4_ho06', 's4_ho08', 's4_ho12', 's4_ho16', 's4_ho17']\n✓ Modelo entrenado exitosamente\n\n\n\n\n\n\n\nCode\nprint(\"=== REALIZANDO PREDICCIONES ===\")\ny_pred_train = pipeline.predict(X_train)\ny_pred_test = pipeline.predict(X_test)\n\nprint(f\"Predicciones generadas para {len(y_pred_test)} muestras de prueba\")\nprint(f\"Rango de predicciones: [{y_pred_test.min():.2f}, {y_pred_test.max():.2f}]\")\nprint(f\"Rango real: [{y_test.min():.2f}, {y_test.max():.2f}]\")\n\n\n=== REALIZANDO PREDICCIONES ===\nPredicciones generadas para 513087 muestras de prueba\nRango de predicciones: [-45.74, 86.93]\nRango real: [1.00, 10.00]\n\n\n\n\n\n\n\nCode\nprint(\"=== EVALUACIÓN DEL MODELO ===\")\n# Métricas en conjunto de entrenamiento\nmse_train = mean_squared_error(y_train, y_pred_train)\nrmse_train = np.sqrt(mse_train)\nr2_train = r2_score(y_train, y_pred_train)\n\n# Métricas en conjunto de prueba\nmse_test = mean_squared_error(y_test, y_pred_test)\nrmse_test = np.sqrt(mse_test)\nr2_test = r2_score(y_test, y_pred_test)\n\n# Crear DataFrame con métricas\nmetricas = pd.DataFrame({\n    'Métrica': ['MSE', 'RMSE', 'R² Score'],\n    'Entrenamiento': [mse_train, rmse_train, r2_train],\n    'Prueba': [mse_test, rmse_test, r2_test],\n    'Interpretación': [\n        f'Error cuadrático medio: {mse_test:.3f}',\n        f'Error promedio: ±{rmse_test:.2f} deciles',\n        f'Varianza explicada: {r2_test*100:.1f}%'\n    ]\n})\n\nprint(metricas.to_string(index=False))\n\n\n=== EVALUACIÓN DEL MODELO ===\n Métrica  Entrenamiento   Prueba                Interpretación\n     MSE       3.466656 3.385502 Error cuadrático medio: 3.386\n    RMSE       1.861896 1.839973 Error promedio: ±1.84 deciles\nR² Score       0.378183 0.392704     Varianza explicada: 39.3%\n\n\n\n\n\n\n\n\n\nCode\nplt.figure(figsize=(10, 8))\nplt.scatter(y_test, y_pred_test, alpha=0.6, color='blue', s=20)\nplt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)\nplt.xlabel('Deciles Reales')\nplt.ylabel('Deciles Predichos')\nplt.title('Valores Reales vs Predichos - Deciles Socioeconómicos', fontsize=14, fontweight='bold')\nplt.grid(alpha=0.3)\n\n# Añadir métricas al gráfico\nplt.text(0.05, 0.95, f'R² = {r2_test:.3f}\\nRMSE = {rmse_test:.2f}', \n         transform=plt.gca().transAxes, fontsize=12, \n         verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplt.figure(figsize=(12, 5))\n\n# Subplot 1: Histograma de errores\nplt.subplot(1, 2, 1)\nerrors = y_test - y_pred_test\nplt.hist(errors, bins=30, edgecolor='black', alpha=0.7, color='lightcoral')\nplt.xlabel('Error (Real - Predicho)')\nplt.ylabel('Frecuencia')\nplt.title('Distribución de Errores', fontweight='bold')\nplt.axvline(x=0, color='red', linestyle='--', alpha=0.8)\nplt.grid(alpha=0.3)\n\n# Subplot 2: Errores vs valores predichos\nplt.subplot(1, 2, 2)\nplt.scatter(y_pred_test, errors, alpha=0.6, color='green', s=20)\nplt.xlabel('Valores Predichos')\nplt.ylabel('Error (Real - Predicho)')\nplt.title('Errores vs Valores Predichos', fontweight='bold')\nplt.axhline(y=0, color='red', linestyle='--', alpha=0.8)\nplt.grid(alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nprint(\"=== GENERANDO CURVA DE APRENDIZAJE ===\")\ntrain_sizes, train_scores, val_scores = learning_curve(\n    pipeline, X_train, y_train, cv=5, \n    train_sizes=np.linspace(0.1, 1.0, 10),\n    scoring='r2', random_state=42\n)\n\n# Calcular medias y desviaciones estándar\ntrain_mean = np.mean(train_scores, axis=1)\ntrain_std = np.std(train_scores, axis=1)\nval_mean = np.mean(val_scores, axis=1)\nval_std = np.std(val_scores, axis=1)\n\nplt.figure(figsize=(10, 6))\nplt.plot(train_sizes, train_mean, 'o-', color='blue', label='Entrenamiento')\nplt.fill_between(train_sizes, train_mean - train_std, train_mean + train_std, alpha=0.1, color='blue')\nplt.plot(train_sizes, val_mean, 'o-', color='red', label='Validación')\nplt.fill_between(train_sizes, val_mean - val_std, val_mean + val_std, alpha=0.1, color='red')\n\nplt.xlabel('Tamaño del Conjunto de Entrenamiento')\nplt.ylabel('R² Score')\nplt.title('Curva de Aprendizaje - Regresión de Deciles', fontsize=14, fontweight='bold')\nplt.legend()\nplt.grid(alpha=0.3)\nplt.tight_layout()\nplt.show()\n\n\n=== GENERANDO CURVA DE APRENDIZAJE ===\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nprint(\"=== ANÁLISIS DE IMPORTANCIA DE FEATURES ===\")\n# Obtener nombres de features después del preprocesamiento\nfeature_names = (available_numerical + \n                list(pipeline.named_steps['preprocessor']\n                    .named_transformers_['cat']\n                    .get_feature_names_out(available_categorical)))\n\ncoefficients = pipeline.named_steps['regressor'].coef_\n\n# Crear DataFrame con importancias\nfeature_importance = pd.DataFrame({\n    'feature': feature_names,\n    'coefficient': coefficients,\n    'abs_coefficient': np.abs(coefficients)\n}).sort_values('abs_coefficient', ascending=False)\n\n# Mapeo de nombres descriptivos para interpretación\nfeature_descriptions = {\n    'tot_personas': 'Total de personas en el hogar',\n    'tot_nucleos': 'Total de núcleos familiares', \n    'tot_hogares': 'Total de hogares en el área'\n}\n\nprint(\"Top 15 features más importantes:\")\nfor _, row in feature_importance.head(15).iterrows():\n    var_name = row['feature']\n    coef = row['coefficient']\n    \n    # Descripción más clara para variables categóricas\n    if var_name in feature_descriptions:\n        description = feature_descriptions[var_name]\n    elif 's3_vi03' in var_name:\n        description = f'Material del piso (categoría {var_name.split(\"_\")[-1]})'\n    elif 's3_vi04' in var_name:\n        description = f'Material del techo (categoría {var_name.split(\"_\")[-1]})'\n    elif 's3_vi05' in var_name:\n        description = f'Material de paredes (categoría {var_name.split(\"_\")[-1]})'\n    elif 's4_ho01' in var_name:\n        description = f'Procedencia del agua (categoría {var_name.split(\"_\")[-1]})'\n    elif 's4_ho06' in var_name:\n        description = f'Servicio eléctrico (categoría {var_name.split(\"_\")[-1]})'\n    elif 's4_ho08' in var_name:\n        description = f'Servicio higiénico (categoría {var_name.split(\"_\")[-1]})'\n    elif 's4_ho12' in var_name:\n        description = f'Teléfono fijo (categoría {var_name.split(\"_\")[-1]})'\n    elif 's4_ho16' in var_name:\n        description = f'Recolección de basura (categoría {var_name.split(\"_\")[-1]})'\n    elif 's4_ho17' in var_name:\n        description = f'Combustible para cocinar (categoría {var_name.split(\"_\")[-1]})'\n    else:\n        description = 'Variable del hogar'\n    \n    print(f\"{var_name:25} | {coef:8.3f} | {description}\")\n\n\n=== ANÁLISIS DE IMPORTANCIA DE FEATURES ===\nTop 15 features más importantes:\ntot_personas              |   -2.653 | Total de personas en el hogar\ns3_vi04_7                 |   -1.847 | Material del techo (categoría 7)\ntot_nucleos               |    1.704 | Total de núcleos familiares\ns3_vi04_6                 |   -1.578 | Material del techo (categoría 6)\ns3_vi04_4                 |   -1.436 | Material del techo (categoría 4)\ns3_vi04_5                 |   -1.260 | Material del techo (categoría 5)\ns3_vi04_8                 |   -1.080 | Material del techo (categoría 8)\ns4_ho12_5                 |   -0.965 | Teléfono fijo (categoría 5)\ns4_ho12_6                 |   -0.955 | Teléfono fijo (categoría 6)\ns4_ho12_3                 |   -0.897 | Teléfono fijo (categoría 3)\ntot_hogares               |    0.859 | Total de hogares en el área\ns4_ho17_3                 |    0.799 | Combustible para cocinar (categoría 3)\ns4_ho01_3                 |   -0.794 | Procedencia del agua (categoría 3)\ns4_ho17_2                 |   -0.750 | Combustible para cocinar (categoría 2)\ns4_ho01_4                 |   -0.713 | Procedencia del agua (categoría 4)\n\n\n\n\nCode\n# Visualizar importancia de features (solo top 15)\nplt.figure(figsize=(12, 8))\ntop_features = feature_importance.head(15)  # Solo las 15 más importantes\ncolors = ['red' if coef &lt; 0 else 'green' for coef in top_features['coefficient']]\nplt.barh(range(len(top_features)), top_features['coefficient'], color=colors)\nplt.yticks(range(len(top_features)), top_features['feature'])\nplt.xlabel('Coeficiente')\nplt.title('Top 15 Features Más Importantes (Coeficientes de Regresión)', fontsize=14, fontweight='bold')\nplt.grid(axis='x', alpha=0.3)\n\n# Añadir línea en x=0\nplt.axvline(x=0, color='black', linestyle='-', alpha=0.8)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nprint(\"=== ANÁLISIS POR DECILES ===\")\n# Crear DataFrame con resultados por decil\nresults_by_decil = pd.DataFrame({\n    'decil_real': y_test,\n    'decil_predicho': y_pred_test,\n    'error': y_test - y_pred_test,\n    'error_abs': np.abs(y_test - y_pred_test)\n})\n\n# Estadísticas por decil real\ndecil_stats = results_by_decil.groupby('decil_real').agg({\n    'decil_predicho': ['mean', 'std'],\n    'error': ['mean', 'std'],\n    'error_abs': 'mean'\n}).round(3)\n\nprint(\"Estadísticas por decil real:\")\nprint(decil_stats)\n\n\n=== ANÁLISIS POR DECILES ===\nEstadísticas por decil real:\n           decil_predicho         error        error_abs\n                     mean    std   mean    std      mean\ndecil_real                                              \n1                   2.513  1.048 -1.513  1.048     1.569\n2                   3.299  1.036 -1.299  1.036     1.379\n3                   3.798  1.047 -0.798  1.047     1.038\n4                   4.171  1.061 -0.171  1.061     0.841\n5                   4.461  1.061  0.539  1.061     0.958\n6                   4.724  1.095  1.276  1.095     1.381\n7                   4.989  1.117  2.011  1.117     2.045\n8                   5.334  1.338  2.666  1.338     2.721\n9                   5.713  1.403  3.287  1.403     3.357\n10                  6.107  1.227  3.893  1.227     3.945\n\n\n\n\nCode\n# Visualización por deciles\nplt.figure(figsize=(12, 8))\n\n# Boxplot de predicciones por decil real\nplt.subplot(2, 2, 1)\nresults_by_decil.boxplot(column='decil_predicho', by='decil_real', ax=plt.gca())\nplt.title('Predicciones por Decil Real')\nplt.xlabel('Decil Real')\nplt.ylabel('Decil Predicho')\n\n# Boxplot de errores por decil real\nplt.subplot(2, 2, 2)\nresults_by_decil.boxplot(column='error_abs', by='decil_real', ax=plt.gca())\nplt.title('Error Absoluto por Decil Real')\nplt.xlabel('Decil Real')\nplt.ylabel('Error Absoluto')\n\n# Scatter plot con colores por decil\nplt.subplot(2, 2, 3)\nscatter = plt.scatter(results_by_decil['decil_real'], results_by_decil['decil_predicho'], \n                     c=results_by_decil['decil_real'], cmap='viridis', alpha=0.6)\nplt.plot([1, 10], [1, 10], 'r--', alpha=0.8)\nplt.xlabel('Decil Real')\nplt.ylabel('Decil Predicho')\nplt.title('Predicciones Coloreadas por Decil')\nplt.colorbar(scatter)\n\n# Histograma de errores\nplt.subplot(2, 2, 4)\nplt.hist(results_by_decil['error'], bins=20, edgecolor='black', alpha=0.7)\nplt.xlabel('Error (Real - Predicho)')\nplt.ylabel('Frecuencia')\nplt.title('Distribución de Errores')\nplt.axvline(x=0, color='red', linestyle='--', alpha=0.8)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEl modelo de regresión lineal con preprocesamiento correcto muestra los siguientes resultados:\n\nR² Score (0.393): El modelo explica el 39.3% de la varianza en los deciles socioeconómicos\nRMSE (1.84): Error promedio de aproximadamente 1.8 deciles\n\nMejora significativa: El tratamiento correcto de variables categóricas mejoró el rendimiento predictivo\n\n\n\n\nEl análisis con preprocesamiento correcto revela patrones más precisos:\n\nComposición del hogar:\n\nTotal de personas (coef: -2.65): Hogares más grandes tienden a ser más pobres\nTotal de núcleos (coef: +1.70): Más núcleos familiares indica mejor situación económica\n\nMaterial del techo (altamente predictivo):\n\nCategorías específicas (4, 5, 6, 7, 8) están fuertemente asociadas con pobreza\nEl material del techo es el segundo factor más importante después del tamaño del hogar\n\nAcceso a servicios de comunicación:\n\nTeléfono fijo: Ciertas categorías (ausencia o tipo básico) predicen deciles más bajos\nRefleja el acceso a servicios modernos de comunicación\n\nInfraestructura de la vivienda:\n\nMateriales de construcción específicos son marcadores claros de nivel socioeconómico\n\n\n\n\n\n\nDeciles bajos (1-3): Mejor predicción, características más homogéneas\nDeciles medios (4-7): Mayor variabilidad en las predicciones\nDeciles altos (8-10): Tendencia a subestimar el nivel socioeconómico\n\n\n\n\nEl modelo presenta algunas limitaciones importantes que deben considerarse al interpretar los resultados:\n\nVarianza no explicada: El modelo explica aproximadamente el 39.3% de la variabilidad en los deciles socioeconómicos, lo que significa que existe un 60.7% de varianza que no está siendo capturada. Esto sugiere que hay factores socioeconómicos importantes que no están incluidos en nuestro conjunto de variables, como ingresos familiares, educación, empleo, etc.\nSimplicidad del modelo lineal: La regresión lineal asume relaciones lineales entre las variables, pero en la realidad socioeconómica, las relaciones suelen ser más complejas y no lineales.\nVariables seleccionadas limitadas: De las 29 características disponibles en el dataset, solo utilizamos 13 variables. Es posible que otras características como ubicación geográfica (provincia, cantón) o variables adicionales de la vivienda podrían mejorar la precisión del modelo.\n\n\n\n\n\n\nMaterial del techo es altamente predictivo: Las categorías específicas de materiales de construcción son marcadores claros de nivel socioeconómico, siendo el segundo factor más importante\nComposición del hogar es el factor más crítico: Hogares con más personas tienden a ser más pobres, mientras que más núcleos familiares indica mejor situación económica\nServicios de comunicación reflejan desigualdad: El acceso a teléfono fijo y su tipo son indicadores importantes del nivel socioeconómico\nAplicaciones en política social: El modelo puede identificar hogares vulnerables basándose en características observables de la vivienda y composición familiar\n\n\n\n\nIdentificación de vulnerabilidad: El modelo puede ayudar a identificar hogares en situación de pobreza\nPlanificación urbana: Priorización de inversiones en infraestructura"
  },
  {
    "objectID": "regresion_hogares.html#introducción",
    "href": "regresion_hogares.html#introducción",
    "title": "Regresión - Predicción de Deciles Socioeconómicos",
    "section": "",
    "text": "Este documento presenta un modelo de regresión lineal para predecir el decil socioeconómico de hogares ecuatorianos utilizando datos de la Encuesta de Condiciones de Vida 2018.\nObjetivo: Desarrollar un modelo predictivo que estime el nivel socioeconómico basado en características del hogar y ubicación geográfica."
  },
  {
    "objectID": "regresion_hogares.html#carga-y-exploración-del-dataset",
    "href": "regresion_hogares.html#carga-y-exploración-del-dataset",
    "title": "Regresión - Predicción de Deciles Socioeconómicos",
    "section": "",
    "text": "Code\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split, learning_curve\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.metrics import mean_squared_error, r2_score\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Configurar matplotlib\nplt.style.use('default')\nsns.set_palette(\"husl\")\n\nprint(\"=== SISTEMA DE REGRESIÓN - DECILES SOCIOECONÓMICOS ===\")\n\n\n=== SISTEMA DE REGRESIÓN - DECILES SOCIOECONÓMICOS ===\n\n\n\n\nCode\n# Cargar datos principales\ndf = pd.read_csv('DATOS_REGRESSION/hogares_rs18.csv', encoding='utf-8')\n\nprint(f\"Datos cargados: {df.shape[0]} filas, {df.shape[1]} columnas\")\nprint(f\"Columnas disponibles: {list(df.columns)}\")\n\n\nDatos cargados: 2565433 filas, 29 columnas\nColumnas disponibles: ['s1_id06_cod', 's1_id06_des', 's1_id05_cod', 's1_id05_des', 's1_id04_cod', 's1_id04_des', 's1_id03', 's3_vi02', 's3_vi05_est', 's3_vi04_est', 's3_vi03_est', 's3_vi05', 's3_vi04', 's3_vi03', 's3_vi01', 's4_ho08', 's4_ho17', 's4_ho16', 's4_ho06', 's4_ho01', 's4_ho19', 's4_ho12', 's4_ho21', 's4_ho22', 'decil', 'tipo_pob_rs18', 'tot_hogares', 'tot_nucleos', 'tot_personas']\n\n\n\n\nCode\n# Diccionario de variables conocidas\nvariable_mapping = {\n    'decil': 'Decil socioeconómico del hogar (1=más pobre, 10=más rico)',\n    'tipo_pob_rs18': 'Tipo de pobreza del hogar',\n    'tot_hogares': 'Total de hogares en el área',\n    'tot_nucleos': 'Total de núcleos familiares',\n    'tot_personas': 'Total de personas en el hogar',\n    's1_id03': 'Código de área (1=Urbano, 0=Rural)',\n    's3_vi01': 'Tipo de vivienda',\n    's3_vi03': 'Material predominante del piso',\n    's3_vi04': 'Material predominante del techo',\n    's3_vi05': 'Material predominante de las paredes',\n    's4_ho01': 'Procedencia principal del agua',\n    's4_ho06': 'Tipo de servicio eléctrico',\n    's4_ho08': 'Tipo de servicio higiénico',\n    's4_ho12': 'Servicio telefónico convencional',\n    's4_ho16': 'Eliminación de la basura',\n    's4_ho17': 'Combustible para cocinar'\n}\n\nprint(\"=== DICCIONARIO DE VARIABLES ===\")\nfor var, desc in variable_mapping.items():\n    print(f\"{var}: {desc}\")\n\n\n=== DICCIONARIO DE VARIABLES ===\ndecil: Decil socioeconómico del hogar (1=más pobre, 10=más rico)\ntipo_pob_rs18: Tipo de pobreza del hogar\ntot_hogares: Total de hogares en el área\ntot_nucleos: Total de núcleos familiares\ntot_personas: Total de personas en el hogar\ns1_id03: Código de área (1=Urbano, 0=Rural)\ns3_vi01: Tipo de vivienda\ns3_vi03: Material predominante del piso\ns3_vi04: Material predominante del techo\ns3_vi05: Material predominante de las paredes\ns4_ho01: Procedencia principal del agua\ns4_ho06: Tipo de servicio eléctrico\ns4_ho08: Tipo de servicio higiénico\ns4_ho12: Servicio telefónico convencional\ns4_ho16: Eliminación de la basura\ns4_ho17: Combustible para cocinar"
  },
  {
    "objectID": "regresion_hogares.html#exploración-de-datos",
    "href": "regresion_hogares.html#exploración-de-datos",
    "title": "Regresión - Predicción de Deciles Socioeconómicos",
    "section": "",
    "text": "Code\nprint(\"=== EXPLORACIÓN INICIAL ===\")\nprint(f\"Forma del dataset: {df.shape}\")\nprint(f\"\\nPrimeras 5 filas:\")\ndf.head()\n\n\n=== EXPLORACIÓN INICIAL ===\nForma del dataset: (2565433, 29)\n\nPrimeras 5 filas:\n\n\n\n\n\n\n\n\n\ns1_id06_cod\ns1_id06_des\ns1_id05_cod\ns1_id05_des\ns1_id04_cod\ns1_id04_des\ns1_id03\ns3_vi02\ns3_vi05_est\ns3_vi04_est\n...\ns4_ho01\ns4_ho19\ns4_ho12\ns4_ho21\ns4_ho22\ndecil\ntipo_pob_rs18\ntot_hogares\ntot_nucleos\ntot_personas\n\n\n\n\n0\n10150\nCUENCA\n101\nCUENCA\n1\nAZUAY\n1\n1\n1\n1\n...\n1\n1\n1\n1\n1\n8\nNo pobre\n2\n3\n9\n\n\n1\n10150\nCUENCA\n101\nCUENCA\n1\nAZUAY\n1\n1\n1\n1\n...\n1\n1\n1\n1\n1\n9\nNo pobre\n5\n5\n22\n\n\n2\n10150\nCUENCA\n101\nCUENCA\n1\nAZUAY\n1\n1\n1\n1\n...\n1\n1\n1\n1\n1\n10\nNo pobre\n1\n1\n2\n\n\n3\n10150\nCUENCA\n101\nCUENCA\n1\nAZUAY\n1\n1\n1\n1\n...\n1\n1\n1\n1\n2\n4\nNo pobre\n1\n2\n7\n\n\n4\n10150\nCUENCA\n101\nCUENCA\n1\nAZUAY\n1\n1\n1\n1\n...\n1\n1\n1\n1\n2\n5\nNo pobre\n2\n3\n12\n\n\n\n\n5 rows × 29 columns\n\n\n\n\n\nCode\n# Estadísticas descriptivas de variables clave\nprint(\"=== ESTADÍSTICAS DESCRIPTIVAS ===\")\nkey_columns = ['decil', 'tot_hogares', 'tot_personas', 's3_vi01', 'tipo_pob_rs18']\nexisting_cols = [col for col in key_columns if col in df.columns]\nif existing_cols:\n    df[existing_cols].describe()\nelse:\n    print(\"No se encontraron las columnas esperadas\")\n\n\n=== ESTADÍSTICAS DESCRIPTIVAS ===\n\n\n\n\nCode\n# Verificar valores faltantes\nprint(\"=== VALORES FALTANTES ===\")\nmissing_data = df.isnull().sum()\nmissing_percent = (missing_data / len(df)) * 100\nmissing_df = pd.DataFrame({\n    'Columna': missing_data.index,\n    'Valores_Faltantes': missing_data.values,\n    'Porcentaje': missing_percent.values\n}).sort_values('Valores_Faltantes', ascending=False)\n\nprint(missing_df.head(10))\n\n\n=== VALORES FALTANTES ===\n          Columna  Valores_Faltantes  Porcentaje\n0     s1_id06_cod                  0         0.0\n15        s4_ho08                  0         0.0\n27    tot_nucleos                  0         0.0\n26    tot_hogares                  0         0.0\n25  tipo_pob_rs18                  0         0.0\n24          decil                  0         0.0\n23        s4_ho22                  0         0.0\n22        s4_ho21                  0         0.0\n21        s4_ho12                  0         0.0\n20        s4_ho19                  0         0.0"
  },
  {
    "objectID": "regresion_hogares.html#definición-de-variable-objetivo-y-features",
    "href": "regresion_hogares.html#definición-de-variable-objetivo-y-features",
    "title": "Regresión - Predicción de Deciles Socioeconómicos",
    "section": "",
    "text": "Code\nprint(\"=== DEFINIENDO VARIABLE OBJETIVO ===\")\n# Variable objetivo: decil socioeconómico\ntarget_col = 'decil'\nif target_col in df.columns:\n    print(f\"Variable objetivo: {target_col}\")\n    print(f\"Distribución de deciles:\")\n    print(df[target_col].value_counts().sort_index())\n    \n    # Visualizar distribución\n    plt.figure(figsize=(10, 6))\n    df[target_col].hist(bins=10, edgecolor='black', alpha=0.7, color='skyblue')\n    plt.title('Distribución de Deciles Socioeconómicos', fontsize=14, fontweight='bold')\n    plt.xlabel('Decil')\n    plt.ylabel('Frecuencia')\n    plt.grid(alpha=0.3)\n    plt.show()\nelse:\n    print(f\"ERROR: Columna {target_col} no encontrada\")\n\n\n=== DEFINIENDO VARIABLE OBJETIVO ===\nVariable objetivo: decil\nDistribución de deciles:\n1     382465\n2     499175\n3     403812\n4     334334\n5     263928\n6     228965\n7     192018\n8     143883\n9      86887\n10     29966\nName: decil, dtype: int64\n\n\n\n\n\n\n\n\n\n\n\nCode\nprint(\"=== SELECCIONANDO Y CLASIFICANDO FEATURES ===\")\n# Primero ver todas las columnas disponibles\nprint(\"Columnas disponibles en el dataset:\")\nprint(list(df.columns))\n\n# Clasificar features por tipo de datos\nnumerical_features = [\n    'tot_hogares',   # Total de hogares\n    'tot_nucleos',   # Total de núcleos familiares\n    'tot_personas'   # Total de personas\n]\n\ncategorical_features = [\n    's3_vi01',       # Tipo de vivienda\n    's3_vi03',       # Material de piso\n    's3_vi04',       # Material de techo  \n    's3_vi05',       # Material de paredes\n    's4_ho01',       # Procedencia del agua\n    's4_ho06',       # Servicio eléctrico\n    's4_ho08',       # Servicio higiénico\n    's4_ho12',       # Teléfono convencional\n    's4_ho16',       # Eliminación de basura\n    's4_ho17'        # Combustible para cocinar\n]\n\nall_features = numerical_features + categorical_features\n\n# Verificar qué columnas existen\navailable_numerical = [col for col in numerical_features if col in df.columns]\navailable_categorical = [col for col in categorical_features if col in df.columns]\navailable_features = available_numerical + available_categorical\n\nprint(f\"Features numéricas disponibles: {available_numerical}\")\nprint(f\"Features categóricas disponibles: {available_categorical}\")\nprint(f\"Total features: {len(available_features)}\")\n\n\n=== SELECCIONANDO Y CLASIFICANDO FEATURES ===\nColumnas disponibles en el dataset:\n['s1_id06_cod', 's1_id06_des', 's1_id05_cod', 's1_id05_des', 's1_id04_cod', 's1_id04_des', 's1_id03', 's3_vi02', 's3_vi05_est', 's3_vi04_est', 's3_vi03_est', 's3_vi05', 's3_vi04', 's3_vi03', 's3_vi01', 's4_ho08', 's4_ho17', 's4_ho16', 's4_ho06', 's4_ho01', 's4_ho19', 's4_ho12', 's4_ho21', 's4_ho22', 'decil', 'tipo_pob_rs18', 'tot_hogares', 'tot_nucleos', 'tot_personas']\nFeatures numéricas disponibles: ['tot_hogares', 'tot_nucleos', 'tot_personas']\nFeatures categóricas disponibles: ['s3_vi01', 's3_vi03', 's3_vi04', 's3_vi05', 's4_ho01', 's4_ho06', 's4_ho08', 's4_ho12', 's4_ho16', 's4_ho17']\nTotal features: 13"
  },
  {
    "objectID": "regresion_hogares.html#preparación-de-datos",
    "href": "regresion_hogares.html#preparación-de-datos",
    "title": "Regresión - Predicción de Deciles Socioeconómicos",
    "section": "",
    "text": "Code\nprint(\"=== PREPARANDO DATOS PARA EL MODELO ===\")\n# Crear dataset limpio\nmodel_data = df[available_features + [target_col]].copy()\n\n# Eliminar filas con valores faltantes\ninitial_rows = len(model_data)\nmodel_data = model_data.dropna()\nfinal_rows = len(model_data)\n\nprint(f\"Filas iniciales: {initial_rows}\")\nprint(f\"Filas después de limpiar: {final_rows}\")\nprint(f\"Filas eliminadas: {initial_rows - final_rows}\")\n\n# Separar features y target\nX = model_data[available_features]\ny = model_data[target_col]\n\nprint(f\"Forma final de X: {X.shape}\")\nprint(f\"Forma final de y: {y.shape}\")\nprint(f\"Features numéricas: {available_numerical}\")\nprint(f\"Features categóricas: {available_categorical}\")\n\n\n=== PREPARANDO DATOS PARA EL MODELO ===\nFilas iniciales: 2565433\nFilas después de limpiar: 2565433\nFilas eliminadas: 0\nForma final de X: (2565433, 13)\nForma final de y: (2565433,)\nFeatures numéricas: ['tot_hogares', 'tot_nucleos', 'tot_personas']\nFeatures categóricas: ['s3_vi01', 's3_vi03', 's3_vi04', 's3_vi05', 's4_ho01', 's4_ho06', 's4_ho08', 's4_ho12', 's4_ho16', 's4_ho17']\n\n\n\n\nCode\n# Estadísticas de las features\nprint(\"=== ESTADÍSTICAS DE FEATURES ===\")\nif len(available_features) &gt; 0:\n    X.describe()\nelse:\n    print(\"No hay features disponibles para mostrar estadísticas\")\n\n\n=== ESTADÍSTICAS DE FEATURES ==="
  },
  {
    "objectID": "regresion_hogares.html#división-de-datos",
    "href": "regresion_hogares.html#división-de-datos",
    "title": "Regresión - Predicción de Deciles Socioeconómicos",
    "section": "",
    "text": "Code\nprint(\"=== DIVIDIENDO DATOS ===\")\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42\n)\n\nprint(f\"Entrenamiento: {X_train.shape[0]} muestras\")\nprint(f\"Prueba: {X_test.shape[0]} muestras\")\nprint(f\"Estadísticas del target en entrenamiento:\")\nprint(f\"Media: {y_train.mean():.2f}\")\nprint(f\"Desviación estándar: {y_train.std():.2f}\")\n\n\n=== DIVIDIENDO DATOS ===\nEntrenamiento: 2052346 muestras\nPrueba: 513087 muestras\nEstadísticas del target en entrenamiento:\nMedia: 3.98\nDesviación estándar: 2.36"
  },
  {
    "objectID": "regresion_hogares.html#definición-y-entrenamiento-del-modelo",
    "href": "regresion_hogares.html#definición-y-entrenamiento-del-modelo",
    "title": "Regresión - Predicción de Deciles Socioeconómicos",
    "section": "",
    "text": "Code\nprint(\"=== CREANDO PIPELINE DE REGRESIÓN ===\")\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.preprocessing import OneHotEncoder\n\n# Crear pipeline de preprocesamiento correcto\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('num', StandardScaler(), available_numerical),\n        ('cat', OneHotEncoder(drop='first', handle_unknown='ignore'), available_categorical)\n    ])\n\n# Pipeline completo con preprocesamiento adecuado\npipeline = Pipeline([\n    ('preprocessor', preprocessor),\n    ('regressor', LinearRegression())\n])\n\n# Entrenar modelo\nprint(\"Entrenando modelo LinearRegression con preprocesamiento correcto...\")\nprint(f\"Variables numéricas: {available_numerical}\")\nprint(f\"Variables categóricas: {available_categorical}\")\npipeline.fit(X_train, y_train)\nprint(\"✓ Modelo entrenado exitosamente\")\n\n\n=== CREANDO PIPELINE DE REGRESIÓN ===\nEntrenando modelo LinearRegression con preprocesamiento correcto...\nVariables numéricas: ['tot_hogares', 'tot_nucleos', 'tot_personas']\nVariables categóricas: ['s3_vi01', 's3_vi03', 's3_vi04', 's3_vi05', 's4_ho01', 's4_ho06', 's4_ho08', 's4_ho12', 's4_ho16', 's4_ho17']\n✓ Modelo entrenado exitosamente"
  },
  {
    "objectID": "regresion_hogares.html#generación-de-predicciones",
    "href": "regresion_hogares.html#generación-de-predicciones",
    "title": "Regresión - Predicción de Deciles Socioeconómicos",
    "section": "",
    "text": "Code\nprint(\"=== REALIZANDO PREDICCIONES ===\")\ny_pred_train = pipeline.predict(X_train)\ny_pred_test = pipeline.predict(X_test)\n\nprint(f\"Predicciones generadas para {len(y_pred_test)} muestras de prueba\")\nprint(f\"Rango de predicciones: [{y_pred_test.min():.2f}, {y_pred_test.max():.2f}]\")\nprint(f\"Rango real: [{y_test.min():.2f}, {y_test.max():.2f}]\")\n\n\n=== REALIZANDO PREDICCIONES ===\nPredicciones generadas para 513087 muestras de prueba\nRango de predicciones: [-45.74, 86.93]\nRango real: [1.00, 10.00]"
  },
  {
    "objectID": "regresion_hogares.html#evaluación-del-modelo",
    "href": "regresion_hogares.html#evaluación-del-modelo",
    "title": "Regresión - Predicción de Deciles Socioeconómicos",
    "section": "",
    "text": "Code\nprint(\"=== EVALUACIÓN DEL MODELO ===\")\n# Métricas en conjunto de entrenamiento\nmse_train = mean_squared_error(y_train, y_pred_train)\nrmse_train = np.sqrt(mse_train)\nr2_train = r2_score(y_train, y_pred_train)\n\n# Métricas en conjunto de prueba\nmse_test = mean_squared_error(y_test, y_pred_test)\nrmse_test = np.sqrt(mse_test)\nr2_test = r2_score(y_test, y_pred_test)\n\n# Crear DataFrame con métricas\nmetricas = pd.DataFrame({\n    'Métrica': ['MSE', 'RMSE', 'R² Score'],\n    'Entrenamiento': [mse_train, rmse_train, r2_train],\n    'Prueba': [mse_test, rmse_test, r2_test],\n    'Interpretación': [\n        f'Error cuadrático medio: {mse_test:.3f}',\n        f'Error promedio: ±{rmse_test:.2f} deciles',\n        f'Varianza explicada: {r2_test*100:.1f}%'\n    ]\n})\n\nprint(metricas.to_string(index=False))\n\n\n=== EVALUACIÓN DEL MODELO ===\n Métrica  Entrenamiento   Prueba                Interpretación\n     MSE       3.466656 3.385502 Error cuadrático medio: 3.386\n    RMSE       1.861896 1.839973 Error promedio: ±1.84 deciles\nR² Score       0.378183 0.392704     Varianza explicada: 39.3%"
  },
  {
    "objectID": "regresion_hogares.html#visualizaciones",
    "href": "regresion_hogares.html#visualizaciones",
    "title": "Regresión - Predicción de Deciles Socioeconómicos",
    "section": "",
    "text": "Code\nplt.figure(figsize=(10, 8))\nplt.scatter(y_test, y_pred_test, alpha=0.6, color='blue', s=20)\nplt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)\nplt.xlabel('Deciles Reales')\nplt.ylabel('Deciles Predichos')\nplt.title('Valores Reales vs Predichos - Deciles Socioeconómicos', fontsize=14, fontweight='bold')\nplt.grid(alpha=0.3)\n\n# Añadir métricas al gráfico\nplt.text(0.05, 0.95, f'R² = {r2_test:.3f}\\nRMSE = {rmse_test:.2f}', \n         transform=plt.gca().transAxes, fontsize=12, \n         verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplt.figure(figsize=(12, 5))\n\n# Subplot 1: Histograma de errores\nplt.subplot(1, 2, 1)\nerrors = y_test - y_pred_test\nplt.hist(errors, bins=30, edgecolor='black', alpha=0.7, color='lightcoral')\nplt.xlabel('Error (Real - Predicho)')\nplt.ylabel('Frecuencia')\nplt.title('Distribución de Errores', fontweight='bold')\nplt.axvline(x=0, color='red', linestyle='--', alpha=0.8)\nplt.grid(alpha=0.3)\n\n# Subplot 2: Errores vs valores predichos\nplt.subplot(1, 2, 2)\nplt.scatter(y_pred_test, errors, alpha=0.6, color='green', s=20)\nplt.xlabel('Valores Predichos')\nplt.ylabel('Error (Real - Predicho)')\nplt.title('Errores vs Valores Predichos', fontweight='bold')\nplt.axhline(y=0, color='red', linestyle='--', alpha=0.8)\nplt.grid(alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nprint(\"=== GENERANDO CURVA DE APRENDIZAJE ===\")\ntrain_sizes, train_scores, val_scores = learning_curve(\n    pipeline, X_train, y_train, cv=5, \n    train_sizes=np.linspace(0.1, 1.0, 10),\n    scoring='r2', random_state=42\n)\n\n# Calcular medias y desviaciones estándar\ntrain_mean = np.mean(train_scores, axis=1)\ntrain_std = np.std(train_scores, axis=1)\nval_mean = np.mean(val_scores, axis=1)\nval_std = np.std(val_scores, axis=1)\n\nplt.figure(figsize=(10, 6))\nplt.plot(train_sizes, train_mean, 'o-', color='blue', label='Entrenamiento')\nplt.fill_between(train_sizes, train_mean - train_std, train_mean + train_std, alpha=0.1, color='blue')\nplt.plot(train_sizes, val_mean, 'o-', color='red', label='Validación')\nplt.fill_between(train_sizes, val_mean - val_std, val_mean + val_std, alpha=0.1, color='red')\n\nplt.xlabel('Tamaño del Conjunto de Entrenamiento')\nplt.ylabel('R² Score')\nplt.title('Curva de Aprendizaje - Regresión de Deciles', fontsize=14, fontweight='bold')\nplt.legend()\nplt.grid(alpha=0.3)\nplt.tight_layout()\nplt.show()\n\n\n=== GENERANDO CURVA DE APRENDIZAJE ==="
  },
  {
    "objectID": "regresion_hogares.html#análisis-de-importancia-de-features",
    "href": "regresion_hogares.html#análisis-de-importancia-de-features",
    "title": "Regresión - Predicción de Deciles Socioeconómicos",
    "section": "",
    "text": "Code\nprint(\"=== ANÁLISIS DE IMPORTANCIA DE FEATURES ===\")\n# Obtener nombres de features después del preprocesamiento\nfeature_names = (available_numerical + \n                list(pipeline.named_steps['preprocessor']\n                    .named_transformers_['cat']\n                    .get_feature_names_out(available_categorical)))\n\ncoefficients = pipeline.named_steps['regressor'].coef_\n\n# Crear DataFrame con importancias\nfeature_importance = pd.DataFrame({\n    'feature': feature_names,\n    'coefficient': coefficients,\n    'abs_coefficient': np.abs(coefficients)\n}).sort_values('abs_coefficient', ascending=False)\n\n# Mapeo de nombres descriptivos para interpretación\nfeature_descriptions = {\n    'tot_personas': 'Total de personas en el hogar',\n    'tot_nucleos': 'Total de núcleos familiares', \n    'tot_hogares': 'Total de hogares en el área'\n}\n\nprint(\"Top 15 features más importantes:\")\nfor _, row in feature_importance.head(15).iterrows():\n    var_name = row['feature']\n    coef = row['coefficient']\n    \n    # Descripción más clara para variables categóricas\n    if var_name in feature_descriptions:\n        description = feature_descriptions[var_name]\n    elif 's3_vi03' in var_name:\n        description = f'Material del piso (categoría {var_name.split(\"_\")[-1]})'\n    elif 's3_vi04' in var_name:\n        description = f'Material del techo (categoría {var_name.split(\"_\")[-1]})'\n    elif 's3_vi05' in var_name:\n        description = f'Material de paredes (categoría {var_name.split(\"_\")[-1]})'\n    elif 's4_ho01' in var_name:\n        description = f'Procedencia del agua (categoría {var_name.split(\"_\")[-1]})'\n    elif 's4_ho06' in var_name:\n        description = f'Servicio eléctrico (categoría {var_name.split(\"_\")[-1]})'\n    elif 's4_ho08' in var_name:\n        description = f'Servicio higiénico (categoría {var_name.split(\"_\")[-1]})'\n    elif 's4_ho12' in var_name:\n        description = f'Teléfono fijo (categoría {var_name.split(\"_\")[-1]})'\n    elif 's4_ho16' in var_name:\n        description = f'Recolección de basura (categoría {var_name.split(\"_\")[-1]})'\n    elif 's4_ho17' in var_name:\n        description = f'Combustible para cocinar (categoría {var_name.split(\"_\")[-1]})'\n    else:\n        description = 'Variable del hogar'\n    \n    print(f\"{var_name:25} | {coef:8.3f} | {description}\")\n\n\n=== ANÁLISIS DE IMPORTANCIA DE FEATURES ===\nTop 15 features más importantes:\ntot_personas              |   -2.653 | Total de personas en el hogar\ns3_vi04_7                 |   -1.847 | Material del techo (categoría 7)\ntot_nucleos               |    1.704 | Total de núcleos familiares\ns3_vi04_6                 |   -1.578 | Material del techo (categoría 6)\ns3_vi04_4                 |   -1.436 | Material del techo (categoría 4)\ns3_vi04_5                 |   -1.260 | Material del techo (categoría 5)\ns3_vi04_8                 |   -1.080 | Material del techo (categoría 8)\ns4_ho12_5                 |   -0.965 | Teléfono fijo (categoría 5)\ns4_ho12_6                 |   -0.955 | Teléfono fijo (categoría 6)\ns4_ho12_3                 |   -0.897 | Teléfono fijo (categoría 3)\ntot_hogares               |    0.859 | Total de hogares en el área\ns4_ho17_3                 |    0.799 | Combustible para cocinar (categoría 3)\ns4_ho01_3                 |   -0.794 | Procedencia del agua (categoría 3)\ns4_ho17_2                 |   -0.750 | Combustible para cocinar (categoría 2)\ns4_ho01_4                 |   -0.713 | Procedencia del agua (categoría 4)\n\n\n\n\nCode\n# Visualizar importancia de features (solo top 15)\nplt.figure(figsize=(12, 8))\ntop_features = feature_importance.head(15)  # Solo las 15 más importantes\ncolors = ['red' if coef &lt; 0 else 'green' for coef in top_features['coefficient']]\nplt.barh(range(len(top_features)), top_features['coefficient'], color=colors)\nplt.yticks(range(len(top_features)), top_features['feature'])\nplt.xlabel('Coeficiente')\nplt.title('Top 15 Features Más Importantes (Coeficientes de Regresión)', fontsize=14, fontweight='bold')\nplt.grid(axis='x', alpha=0.3)\n\n# Añadir línea en x=0\nplt.axvline(x=0, color='black', linestyle='-', alpha=0.8)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "regresion_hogares.html#análisis-por-deciles",
    "href": "regresion_hogares.html#análisis-por-deciles",
    "title": "Regresión - Predicción de Deciles Socioeconómicos",
    "section": "",
    "text": "Code\nprint(\"=== ANÁLISIS POR DECILES ===\")\n# Crear DataFrame con resultados por decil\nresults_by_decil = pd.DataFrame({\n    'decil_real': y_test,\n    'decil_predicho': y_pred_test,\n    'error': y_test - y_pred_test,\n    'error_abs': np.abs(y_test - y_pred_test)\n})\n\n# Estadísticas por decil real\ndecil_stats = results_by_decil.groupby('decil_real').agg({\n    'decil_predicho': ['mean', 'std'],\n    'error': ['mean', 'std'],\n    'error_abs': 'mean'\n}).round(3)\n\nprint(\"Estadísticas por decil real:\")\nprint(decil_stats)\n\n\n=== ANÁLISIS POR DECILES ===\nEstadísticas por decil real:\n           decil_predicho         error        error_abs\n                     mean    std   mean    std      mean\ndecil_real                                              \n1                   2.513  1.048 -1.513  1.048     1.569\n2                   3.299  1.036 -1.299  1.036     1.379\n3                   3.798  1.047 -0.798  1.047     1.038\n4                   4.171  1.061 -0.171  1.061     0.841\n5                   4.461  1.061  0.539  1.061     0.958\n6                   4.724  1.095  1.276  1.095     1.381\n7                   4.989  1.117  2.011  1.117     2.045\n8                   5.334  1.338  2.666  1.338     2.721\n9                   5.713  1.403  3.287  1.403     3.357\n10                  6.107  1.227  3.893  1.227     3.945\n\n\n\n\nCode\n# Visualización por deciles\nplt.figure(figsize=(12, 8))\n\n# Boxplot de predicciones por decil real\nplt.subplot(2, 2, 1)\nresults_by_decil.boxplot(column='decil_predicho', by='decil_real', ax=plt.gca())\nplt.title('Predicciones por Decil Real')\nplt.xlabel('Decil Real')\nplt.ylabel('Decil Predicho')\n\n# Boxplot de errores por decil real\nplt.subplot(2, 2, 2)\nresults_by_decil.boxplot(column='error_abs', by='decil_real', ax=plt.gca())\nplt.title('Error Absoluto por Decil Real')\nplt.xlabel('Decil Real')\nplt.ylabel('Error Absoluto')\n\n# Scatter plot con colores por decil\nplt.subplot(2, 2, 3)\nscatter = plt.scatter(results_by_decil['decil_real'], results_by_decil['decil_predicho'], \n                     c=results_by_decil['decil_real'], cmap='viridis', alpha=0.6)\nplt.plot([1, 10], [1, 10], 'r--', alpha=0.8)\nplt.xlabel('Decil Real')\nplt.ylabel('Decil Predicho')\nplt.title('Predicciones Coloreadas por Decil')\nplt.colorbar(scatter)\n\n# Histograma de errores\nplt.subplot(2, 2, 4)\nplt.hist(results_by_decil['error'], bins=20, edgecolor='black', alpha=0.7)\nplt.xlabel('Error (Real - Predicho)')\nplt.ylabel('Frecuencia')\nplt.title('Distribución de Errores')\nplt.axvline(x=0, color='red', linestyle='--', alpha=0.8)\n\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "regresion_hogares.html#interpretación-de-resultados",
    "href": "regresion_hogares.html#interpretación-de-resultados",
    "title": "Regresión - Predicción de Deciles Socioeconómicos",
    "section": "",
    "text": "El modelo de regresión lineal con preprocesamiento correcto muestra los siguientes resultados:\n\nR² Score (0.393): El modelo explica el 39.3% de la varianza en los deciles socioeconómicos\nRMSE (1.84): Error promedio de aproximadamente 1.8 deciles\n\nMejora significativa: El tratamiento correcto de variables categóricas mejoró el rendimiento predictivo\n\n\n\n\nEl análisis con preprocesamiento correcto revela patrones más precisos:\n\nComposición del hogar:\n\nTotal de personas (coef: -2.65): Hogares más grandes tienden a ser más pobres\nTotal de núcleos (coef: +1.70): Más núcleos familiares indica mejor situación económica\n\nMaterial del techo (altamente predictivo):\n\nCategorías específicas (4, 5, 6, 7, 8) están fuertemente asociadas con pobreza\nEl material del techo es el segundo factor más importante después del tamaño del hogar\n\nAcceso a servicios de comunicación:\n\nTeléfono fijo: Ciertas categorías (ausencia o tipo básico) predicen deciles más bajos\nRefleja el acceso a servicios modernos de comunicación\n\nInfraestructura de la vivienda:\n\nMateriales de construcción específicos son marcadores claros de nivel socioeconómico\n\n\n\n\n\n\nDeciles bajos (1-3): Mejor predicción, características más homogéneas\nDeciles medios (4-7): Mayor variabilidad en las predicciones\nDeciles altos (8-10): Tendencia a subestimar el nivel socioeconómico\n\n\n\n\nEl modelo presenta algunas limitaciones importantes que deben considerarse al interpretar los resultados:\n\nVarianza no explicada: El modelo explica aproximadamente el 39.3% de la variabilidad en los deciles socioeconómicos, lo que significa que existe un 60.7% de varianza que no está siendo capturada. Esto sugiere que hay factores socioeconómicos importantes que no están incluidos en nuestro conjunto de variables, como ingresos familiares, educación, empleo, etc.\nSimplicidad del modelo lineal: La regresión lineal asume relaciones lineales entre las variables, pero en la realidad socioeconómica, las relaciones suelen ser más complejas y no lineales.\nVariables seleccionadas limitadas: De las 29 características disponibles en el dataset, solo utilizamos 13 variables. Es posible que otras características como ubicación geográfica (provincia, cantón) o variables adicionales de la vivienda podrían mejorar la precisión del modelo."
  },
  {
    "objectID": "regresion_hogares.html#conclusiones",
    "href": "regresion_hogares.html#conclusiones",
    "title": "Regresión - Predicción de Deciles Socioeconómicos",
    "section": "",
    "text": "Material del techo es altamente predictivo: Las categorías específicas de materiales de construcción son marcadores claros de nivel socioeconómico, siendo el segundo factor más importante\nComposición del hogar es el factor más crítico: Hogares con más personas tienden a ser más pobres, mientras que más núcleos familiares indica mejor situación económica\nServicios de comunicación reflejan desigualdad: El acceso a teléfono fijo y su tipo son indicadores importantes del nivel socioeconómico\nAplicaciones en política social: El modelo puede identificar hogares vulnerables basándose en características observables de la vivienda y composición familiar\n\n\n\n\nIdentificación de vulnerabilidad: El modelo puede ayudar a identificar hogares en situación de pobreza\nPlanificación urbana: Priorización de inversiones en infraestructura"
  },
  {
    "objectID": "trabajo.html",
    "href": "trabajo.html",
    "title": "Análisis de contrataciones",
    "section": "",
    "text": "La siguiente sección muestra la distribución de personas contratadas por cantón para las provincias con mayor y menor número total de contrataciones.\n\n\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nDATA_PATH = \"lab 1 data/mdt_colocados_2025agosto.csv\"\n\ndf = pd.read_csv(DATA_PATH, sep=\";\", encoding=\"latin1\")\ndf = df.rename(\n    columns={\n        \"A¤o\": \"Año\",\n        \"Cant¢n\": \"Cantón\",\n        \"N£mero de Personas\": \"Número de Personas\",\n    }\n)\n\nprovincia_totales = df.groupby(\"Provincia\")[\"Número de Personas\"].sum().sort_values(ascending=False)\ntop4 = provincia_totales.head(4).index.tolist()\n\ndef plot_provincias(provincias, titulo, ranking_label):\n    fig, axes = plt.subplots(2, 2, figsize=(12, 8), sharey=True)\n    fig.suptitle(titulo, fontsize=14, weight=\"bold\")\n\n    for ax, provincia in zip(axes.flatten(), provincias):\n        serie = (\n            df[df[\"Provincia\"] == provincia]\n            .groupby(\"Cantón\")[\"Número de Personas\"]\n            .sum()\n            .sort_values(ascending=False)\n        )\n        ax.bar(serie.index, serie.values, color=\"#4C72B0\")\n        ax.set_title(provincia, fontsize=10)\n        ax.tick_params(axis=\"x\", rotation=70, labelsize=8)\n        if ax in (axes[0, 0], axes[1, 0]):\n            ax.set_ylabel(\"Personas\")\n        else:\n            ax.set_ylabel(\"\")\n        ax.set_xlabel(\"Cantón\", fontsize=9)\n\n        total_provincia = provincia_totales.loc[provincia]\n        ax.text(\n            0.98,\n            0.95,\n            f\"Total: {total_provincia:,}\",\n            transform=ax.transAxes,\n            fontsize=8,\n            fontweight=\"bold\",\n            ha=\"right\",\n            va=\"top\",\n        )\n\n        posicion = provincias.index(provincia) + 1\n        ax.text(\n            0.98,\n            0.85,\n            f\"{ranking_label} {posicion}\",\n            transform=ax.transAxes,\n            fontsize=8,\n            ha=\"right\",\n            va=\"top\",\n        )\n\n        for patch in ax.patches:\n            altura = patch.get_height()\n            if altura &gt; 0:\n                ax.text(\n                    patch.get_x() + patch.get_width() / 2,\n                    altura,\n                    f\"{int(altura):,}\",\n                    ha=\"center\",\n                    va=\"bottom\",\n                    fontsize=7,\n                )\n\n    for ax in axes.flatten()[len(provincias):]:\n        ax.axis(\"off\")\n\n    fig.tight_layout(rect=[0, 0, 1, 0.95])\n    return fig\n\nplot_provincias(top4, \"Provincias con más contrataciones\", \"Top\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nbottom4 = provincia_totales.tail(4).sort_values().index.tolist()\nplot_provincias(bottom4, \"Provincias con menos contrataciones\", \"Bottom\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ncuatrimestral = (\n    df.assign(Cuatrimestre=((df[\"Mes\"] - 1) // 4) + 1)\n    .groupby([\"Año\", \"Cuatrimestre\"])[\"Número de Personas\"]\n    .sum()\n    .reset_index()\n    .sort_values([\"Año\", \"Cuatrimestre\"])\n)\ncuatrimestral[\"Periodo\"] = (\n    cuatrimestral[\"Año\"].astype(str)\n    + \" C\"\n    + cuatrimestral[\"Cuatrimestre\"].astype(str)\n)\n\nplt.figure(figsize=(10, 5))\nplt.plot(\n    cuatrimestral[\"Periodo\"],\n    cuatrimestral[\"Número de Personas\"],\n    marker=\"o\",\n    color=\"#4C72B0\",\n)\nplt.title(\"Evolución cuatrimestral de contrataciones\", fontsize=14, weight=\"bold\")\nplt.xlabel(\"Periodo cuatrimestral\")\nplt.ylabel(\"Personas contratadas\")\nplt.xticks(rotation=45)\n\nfor etiqueta, valor in zip(\n    cuatrimestral[\"Periodo\"], cuatrimestral[\"Número de Personas\"]\n):\n    plt.text(\n        etiqueta,\n        valor,\n        f\"{int(valor):,}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=8,\n    )\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nDATA_PATH = \"lab 1 data/mdt_colocados_2025agosto.csv\"\n\n# Cargar y preparar los datos\ndf = pd.read_csv(DATA_PATH, sep=\";\", encoding=\"latin1\").rename(\n    columns={\n        \"A¤o\": \"Año\",\n        \"Cant¢n\": \"Cantón\",\n        \"N£mero de Personas\": \"Número de Personas\",\n    }\n)\n\nprovincia_totales = df.groupby(\"Provincia\")[\"Número de Personas\"].sum().sort_values(ascending=False)\n\nTOP_N = 12\npie_datos = provincia_totales.reset_index().rename(columns={\"Número de Personas\": \"Personas\"})\ntop_provincias = pie_datos.head(TOP_N)\nresto_total = pie_datos[\"Personas\"][TOP_N:].sum()\n\nif resto_total &gt; 0:\n    pie_data = pd.concat(\n        [top_provincias, pd.DataFrame({\"Provincia\": [\"Otros\"], \"Personas\": [resto_total]})],\n        ignore_index=True,\n    )\nelse:\n    pie_data = top_provincias\n\n\ndef _autopct(values):\n    total = values.sum()\n\n    def inner(pct):\n        valor = int(round(total * pct / 100.0))\n        return f\"{pct:.1f}%\\n{valor:,}\"\n\n    return inner\n\n\nplt.figure(figsize=(8, 8))\nplt.pie(\n    pie_data[\"Personas\"],\n    labels=pie_data[\"Provincia\"],\n    autopct=_autopct(pie_data[\"Personas\"]),\n    startangle=90,\n    pctdistance=0.78,\n    textprops={\"fontsize\": 9},\n)\nplt.title(\"Participación de contrataciones por provincia\", fontsize=14, weight=\"bold\")\ncentre_circle = plt.Circle((0, 0), 0.60, fc=\"white\")\nfig = plt.gcf()\nfig.gca().add_artist(centre_circle)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "trabajo.html#provincias-más-contratadas",
    "href": "trabajo.html#provincias-más-contratadas",
    "title": "Análisis de contrataciones",
    "section": "",
    "text": "Code\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nDATA_PATH = \"lab 1 data/mdt_colocados_2025agosto.csv\"\n\ndf = pd.read_csv(DATA_PATH, sep=\";\", encoding=\"latin1\")\ndf = df.rename(\n    columns={\n        \"A¤o\": \"Año\",\n        \"Cant¢n\": \"Cantón\",\n        \"N£mero de Personas\": \"Número de Personas\",\n    }\n)\n\nprovincia_totales = df.groupby(\"Provincia\")[\"Número de Personas\"].sum().sort_values(ascending=False)\ntop4 = provincia_totales.head(4).index.tolist()\n\ndef plot_provincias(provincias, titulo, ranking_label):\n    fig, axes = plt.subplots(2, 2, figsize=(12, 8), sharey=True)\n    fig.suptitle(titulo, fontsize=14, weight=\"bold\")\n\n    for ax, provincia in zip(axes.flatten(), provincias):\n        serie = (\n            df[df[\"Provincia\"] == provincia]\n            .groupby(\"Cantón\")[\"Número de Personas\"]\n            .sum()\n            .sort_values(ascending=False)\n        )\n        ax.bar(serie.index, serie.values, color=\"#4C72B0\")\n        ax.set_title(provincia, fontsize=10)\n        ax.tick_params(axis=\"x\", rotation=70, labelsize=8)\n        if ax in (axes[0, 0], axes[1, 0]):\n            ax.set_ylabel(\"Personas\")\n        else:\n            ax.set_ylabel(\"\")\n        ax.set_xlabel(\"Cantón\", fontsize=9)\n\n        total_provincia = provincia_totales.loc[provincia]\n        ax.text(\n            0.98,\n            0.95,\n            f\"Total: {total_provincia:,}\",\n            transform=ax.transAxes,\n            fontsize=8,\n            fontweight=\"bold\",\n            ha=\"right\",\n            va=\"top\",\n        )\n\n        posicion = provincias.index(provincia) + 1\n        ax.text(\n            0.98,\n            0.85,\n            f\"{ranking_label} {posicion}\",\n            transform=ax.transAxes,\n            fontsize=8,\n            ha=\"right\",\n            va=\"top\",\n        )\n\n        for patch in ax.patches:\n            altura = patch.get_height()\n            if altura &gt; 0:\n                ax.text(\n                    patch.get_x() + patch.get_width() / 2,\n                    altura,\n                    f\"{int(altura):,}\",\n                    ha=\"center\",\n                    va=\"bottom\",\n                    fontsize=7,\n                )\n\n    for ax in axes.flatten()[len(provincias):]:\n        ax.axis(\"off\")\n\n    fig.tight_layout(rect=[0, 0, 1, 0.95])\n    return fig\n\nplot_provincias(top4, \"Provincias con más contrataciones\", \"Top\")\nplt.show()"
  },
  {
    "objectID": "trabajo.html#provincias-menos-contratadas",
    "href": "trabajo.html#provincias-menos-contratadas",
    "title": "Análisis de contrataciones",
    "section": "",
    "text": "Code\nbottom4 = provincia_totales.tail(4).sort_values().index.tolist()\nplot_provincias(bottom4, \"Provincias con menos contrataciones\", \"Bottom\")\nplt.show()"
  },
  {
    "objectID": "trabajo.html#evolución-cuatrimestral-de-contrataciones",
    "href": "trabajo.html#evolución-cuatrimestral-de-contrataciones",
    "title": "Análisis de contrataciones",
    "section": "",
    "text": "Code\ncuatrimestral = (\n    df.assign(Cuatrimestre=((df[\"Mes\"] - 1) // 4) + 1)\n    .groupby([\"Año\", \"Cuatrimestre\"])[\"Número de Personas\"]\n    .sum()\n    .reset_index()\n    .sort_values([\"Año\", \"Cuatrimestre\"])\n)\ncuatrimestral[\"Periodo\"] = (\n    cuatrimestral[\"Año\"].astype(str)\n    + \" C\"\n    + cuatrimestral[\"Cuatrimestre\"].astype(str)\n)\n\nplt.figure(figsize=(10, 5))\nplt.plot(\n    cuatrimestral[\"Periodo\"],\n    cuatrimestral[\"Número de Personas\"],\n    marker=\"o\",\n    color=\"#4C72B0\",\n)\nplt.title(\"Evolución cuatrimestral de contrataciones\", fontsize=14, weight=\"bold\")\nplt.xlabel(\"Periodo cuatrimestral\")\nplt.ylabel(\"Personas contratadas\")\nplt.xticks(rotation=45)\n\nfor etiqueta, valor in zip(\n    cuatrimestral[\"Periodo\"], cuatrimestral[\"Número de Personas\"]\n):\n    plt.text(\n        etiqueta,\n        valor,\n        f\"{int(valor):,}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=8,\n    )\n\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "trabajo.html#trabajo-por-provincia",
    "href": "trabajo.html#trabajo-por-provincia",
    "title": "Análisis de contrataciones",
    "section": "",
    "text": "Code\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nDATA_PATH = \"lab 1 data/mdt_colocados_2025agosto.csv\"\n\n# Cargar y preparar los datos\ndf = pd.read_csv(DATA_PATH, sep=\";\", encoding=\"latin1\").rename(\n    columns={\n        \"A¤o\": \"Año\",\n        \"Cant¢n\": \"Cantón\",\n        \"N£mero de Personas\": \"Número de Personas\",\n    }\n)\n\nprovincia_totales = df.groupby(\"Provincia\")[\"Número de Personas\"].sum().sort_values(ascending=False)\n\nTOP_N = 12\npie_datos = provincia_totales.reset_index().rename(columns={\"Número de Personas\": \"Personas\"})\ntop_provincias = pie_datos.head(TOP_N)\nresto_total = pie_datos[\"Personas\"][TOP_N:].sum()\n\nif resto_total &gt; 0:\n    pie_data = pd.concat(\n        [top_provincias, pd.DataFrame({\"Provincia\": [\"Otros\"], \"Personas\": [resto_total]})],\n        ignore_index=True,\n    )\nelse:\n    pie_data = top_provincias\n\n\ndef _autopct(values):\n    total = values.sum()\n\n    def inner(pct):\n        valor = int(round(total * pct / 100.0))\n        return f\"{pct:.1f}%\\n{valor:,}\"\n\n    return inner\n\n\nplt.figure(figsize=(8, 8))\nplt.pie(\n    pie_data[\"Personas\"],\n    labels=pie_data[\"Provincia\"],\n    autopct=_autopct(pie_data[\"Personas\"]),\n    startangle=90,\n    pctdistance=0.78,\n    textprops={\"fontsize\": 9},\n)\nplt.title(\"Participación de contrataciones por provincia\", fontsize=14, weight=\"bold\")\ncentre_circle = plt.Circle((0, 0), 0.60, fc=\"white\")\nfig = plt.gcf()\nfig.gca().add_artist(centre_circle)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Primer proyecto en Quarto",
    "section": "",
    "text": "Título -\n\n\nSubtítulo - second\n\n\nCode\nimport altair as alt\nfrom vega_datasets import data\ncars = data.cars()\nprint(cars.head())\n\n\n                        Name  Miles_per_Gallon  Cylinders  Displacement  \\\n0  chevrolet chevelle malibu              18.0          8         307.0   \n1          buick skylark 320              15.0          8         350.0   \n2         plymouth satellite              18.0          8         318.0   \n3              amc rebel sst              16.0          8         304.0   \n4                ford torino              17.0          8         302.0   \n\n   Horsepower  Weight_in_lbs  Acceleration       Year Origin  \n0       130.0           3504          12.0 1970-01-01    USA  \n1       165.0           3693          11.5 1970-01-01    USA  \n2       150.0           3436          11.0 1970-01-01    USA  \n3       150.0           3433          12.0 1970-01-01    USA  \n4       140.0           3449          10.5 1970-01-01    USA  \n\n\n\n\nCode\nalt.Chart(cars).mark_point().encode(\n    x='Miles_per_Gallon',\n    y='Horsepower',\n    tooltip=['Name', 'Miles_per_Gallon', 'Horsepower', 'Origin'],\n    color='Origin'\n).interactive()\n\n\n\n\n\n\n\n\nVisualisacion scatter plot with shape and color\n\n\nCode\nalt.Chart(cars).mark_point().encode(\n    x='Miles_per_Gallon',\n    y='Horsepower',\n    tooltip=['Name', 'Miles_per_Gallon', 'Horsepower', 'Origin'],\n    color='Origin',\n    shape='Origin'\n).interactive()\n\n\n\n\n\n\n\n\n\nAgregaciones\nGrafica de barras\nNumber de observaciones\n\n\nCode\nalt.Chart(cars).mark_bar().encode(\n    alt.X('Origin', title='Origen', sort='-y'),\n    alt.Y('count()', title='Número de observaciones')\n).interactive()\n\n\n\n\n\n\n\n‘Mean()’ de cada uno de los orgienes\n\n\nCode\nalt.Chart(cars).mark_bar().encode(\n    alt.X('Origin', title='Origen', sort='-y'),\n    alt.Y('mean(Weight_in_lbs)', title='Promedio de Weight_in_lbs'),\n    tooltip=['Origin', 'mean(Weight_in_lbs)']\n).properties(title='Promedio de Weight_in_lbs por Origen', width=200, height=200)\n\n\n\n\n\n\n\nGrafico lineal\n\n\nCode\nalt.Chart(cars).mark_line(point=True).encode(\n    alt.X('Year', title='Año'),\n    alt.Y('mean(Weight_in_lbs)', title='Promedio de Weight_in_lbs'),\n    alt.Color('Origin')\n).properties(title='Promedio de Weight_in_lbs por Año', width=600).interactive()"
  },
  {
    "objectID": "clasificacion_binaria.html",
    "href": "clasificacion_binaria.html",
    "title": "Clasificación Binaria - Siniestros de Tránsito Letales",
    "section": "",
    "text": "Este documento presenta un modelo de clasificación binaria para predecir si un siniestro de tránsito será letal (con fallecidos) o no letal, utilizando datos del INEC Ecuador 2019.\nObjetivo: Desarrollar un sistema predictivo que identifique factores de riesgo asociados con la letalidad de accidentes de tránsito.\n\n\n\n\n\nCode\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler, LabelEncoder\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.metrics import (accuracy_score, precision_score, recall_score, \n                           f1_score, confusion_matrix, classification_report, \n                           roc_curve, auc, roc_auc_score)\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Configurar matplotlib\nplt.style.use('default')\nsns.set_palette(\"husl\")\n\nprint(\"=== SISTEMA DE CLASIFICACIÓN BINARIA - SINIESTROS LETALES ===\")\n\n\n=== SISTEMA DE CLASIFICACIÓN BINARIA - SINIESTROS LETALES ===\n\n\n\n\nCode\n# Cargar datos\ndf = pd.read_csv('DATOS_CLASIFICACION_BINARIA/inec_anuario-de-estadisticas-de-transporte_siniestros-de-transito_2019.csv', \n                 sep=';', encoding='utf-8')\n\nprint(f\"Datos cargados: {df.shape[0]} filas, {df.shape[1]} columnas\")\nprint(\"\\nPrimeras 5 filas:\")\ndf.head()\n\n\nDatos cargados: 24595 filas, 11 columnas\n\nPrimeras 5 filas:\n\n\n\n\n\n\n\n\n\nMES\nDIA\nHORA\nPROVINCIA\nCANTON\nZONA\nNUM_FALLECIDO\nNUM_LESIONADO\nTOTAL_VICTIMAS\nCLASE\nCAUSA\n\n\n\n\n0\nENERO\nMARTES\n11:00 A 11:59\nIMBABURA\nOTAVALO\nURBANA\n0\n0\n0\nPÉRDIDA DE PISTA\nIMPERICIA E IMPRUDENCIA DEL CONDUCTOR\n\n\n1\nENERO\nMARTES\n23:00 A 23:59\nIMBABURA\nIBARRA\nRURAL\n0\n0\n0\nOTROS\nOTRAS CAUSAS\n\n\n2\nENERO\nMARTES\n12:00 A 12:59\nTUNGURAHUA\nAMBATO\nURBANA\n0\n3\n3\nCHOQUES\nNO RESPETA LAS SEÑALES DE TRÁNSITO\n\n\n3\nENERO\nMARTES\n07:00 A 07:59\nTUNGURAHUA\nAMBATO\nRURAL\n0\n1\n1\nATROPELLOS\nEMBRIAGUEZ O DROGA\n\n\n4\nENERO\nMARTES\n04:00 A 04:59\nPICHINCHA\nDISTRITO METROPOLITANO DE QUITO\nURBANA\n0\n0\n0\nESTRELLAMIENTOS\nEXCESO VELOCIDAD\n\n\n\n\n\n\n\n\n\nCode\n# Exploración inicial\nprint(\"=== EXPLORACIÓN DE DATOS ===\")\nprint(f\"Columnas: {list(df.columns)}\")\nprint(f\"\\nValores faltantes por columna:\")\ndf.isnull().sum()\n\n\n=== EXPLORACIÓN DE DATOS ===\nColumnas: ['MES', 'DIA', 'HORA', 'PROVINCIA', 'CANTON', 'ZONA', 'NUM_FALLECIDO', 'NUM_LESIONADO', 'TOTAL_VICTIMAS', 'CLASE', 'CAUSA']\n\nValores faltantes por columna:\n\n\nMES               0\nDIA               0\nHORA              0\nPROVINCIA         0\nCANTON            0\nZONA              0\nNUM_FALLECIDO     0\nNUM_LESIONADO     0\nTOTAL_VICTIMAS    0\nCLASE             0\nCAUSA             0\ndtype: int64\n\n\n\n\n\n\n\nCode\n# Crear variable objetivo binaria\nprint(\"=== CREANDO VARIABLE OBJETIVO ===\")\ndf['SINIESTRO_LETAL'] = (df['NUM_FALLECIDO'] &gt; 0).astype(int)\n\nprint(f\"Distribución de la variable objetivo:\")\nprint(df['SINIESTRO_LETAL'].value_counts())\nprint(f\"Porcentaje de siniestros letales: {df['SINIESTRO_LETAL'].mean()*100:.2f}%\")\n\n# Visualizar distribución\nplt.figure(figsize=(8, 5))\ndf['SINIESTRO_LETAL'].value_counts().plot(kind='bar', color=['skyblue', 'salmon'])\nplt.title('Distribución de Siniestros: Letales vs No Letales')\nplt.xlabel('Tipo de Siniestro')\nplt.ylabel('Cantidad')\nplt.xticks([0, 1], ['No Letal', 'Letal'], rotation=0)\nplt.show()\n\n\n=== CREANDO VARIABLE OBJETIVO ===\nDistribución de la variable objetivo:\n0    22626\n1     1969\nName: SINIESTRO_LETAL, dtype: int64\nPorcentaje de siniestros letales: 8.01%\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nprint(\"=== PREPARANDO FEATURES ===\")\n# Seleccionar columnas para el modelo\nfeature_cols = ['MES', 'DIA', 'HORA', 'PROVINCIA', 'CANTON', 'ZONA', 'CLASE', 'CAUSA']\nX = df[feature_cols].copy()\ny = df['SINIESTRO_LETAL']\n\nprint(f\"Features seleccionadas: {feature_cols}\")\nprint(f\"Forma de X: {X.shape}\")\n\n# Procesar la columna HORA para extraer la hora numérica\ndef extract_hour(hora_str):\n    try:\n        return int(hora_str.split(':')[0])\n    except:\n        return 12  # valor por defecto\n\nX['HORA_NUM'] = X['HORA'].apply(extract_hour)\nX = X.drop('HORA', axis=1)\n\n# Identificar variables categóricas y numéricas\ncategorical_features = ['MES', 'DIA', 'PROVINCIA', 'CANTON', 'ZONA', 'CLASE', 'CAUSA']\nnumerical_features = ['HORA_NUM']\n\nprint(f\"Features categóricas: {categorical_features}\")\nprint(f\"Features numéricas: {numerical_features}\")\n\n\n=== PREPARANDO FEATURES ===\nFeatures seleccionadas: ['MES', 'DIA', 'HORA', 'PROVINCIA', 'CANTON', 'ZONA', 'CLASE', 'CAUSA']\nForma de X: (24595, 8)\nFeatures categóricas: ['MES', 'DIA', 'PROVINCIA', 'CANTON', 'ZONA', 'CLASE', 'CAUSA']\nFeatures numéricas: ['HORA_NUM']\n\n\n\n\n\n\n\nCode\nprint(\"=== DIVIDIENDO DATOS ===\")\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42, stratify=y\n)\n\nprint(f\"Entrenamiento: {X_train.shape[0]} muestras\")\nprint(f\"Prueba: {X_test.shape[0]} muestras\")\nprint(f\"Distribución en entrenamiento:\")\nprint(y_train.value_counts(normalize=True))\n\n\n=== DIVIDIENDO DATOS ===\nEntrenamiento: 19676 muestras\nPrueba: 4919 muestras\nDistribución en entrenamiento:\n0    0.919953\n1    0.080047\nName: SINIESTRO_LETAL, dtype: float64\n\n\n\n\n\n\n\nCode\nprint(\"=== CREANDO PIPELINE ===\")\n# Crear pipeline de preprocesamiento\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('num', StandardScaler(), numerical_features),\n        ('cat', OneHotEncoder(drop='first', handle_unknown='ignore'), categorical_features)\n    ])\n\n# Pipeline completo\npipeline = Pipeline([\n    ('preprocessor', preprocessor),\n    ('classifier', LogisticRegression(random_state=42, max_iter=1000))\n])\n\n# Entrenar modelo\nprint(\"Entrenando modelo LogisticRegression...\")\npipeline.fit(X_train, y_train)\nprint(\"✓ Modelo entrenado exitosamente\")\n\n\n=== CREANDO PIPELINE ===\nEntrenando modelo LogisticRegression...\n✓ Modelo entrenado exitosamente\n\n\n\n\n\n\n\nCode\nprint(\"=== REALIZANDO PREDICCIONES ===\")\ny_pred = pipeline.predict(X_test)\ny_pred_proba = pipeline.predict_proba(X_test)[:, 1]\n\nprint(f\"Predicciones generadas para {len(y_pred)} muestras\")\nprint(f\"Distribución de predicciones:\")\nprint(pd.Series(y_pred).value_counts())\n\n\n=== REALIZANDO PREDICCIONES ===\nPredicciones generadas para 4919 muestras\nDistribución de predicciones:\n0    4860\n1      59\ndtype: int64\n\n\n\n\n\n\n\nCode\nprint(\"=== EVALUACIÓN DEL MODELO ===\")\naccuracy = accuracy_score(y_test, y_pred)\nprecision = precision_score(y_test, y_pred)\nrecall = recall_score(y_test, y_pred)\nf1 = f1_score(y_test, y_pred)\nroc_auc = roc_auc_score(y_test, y_pred_proba)\n\n# Crear DataFrame con métricas\nmetricas = pd.DataFrame({\n    'Métrica': ['Accuracy', 'Precision', 'Recall', 'F1-Score', 'ROC-AUC'],\n    'Valor': [accuracy, precision, recall, f1, roc_auc],\n    'Interpretación': [\n        f'Clasifica correctamente el {accuracy*100:.1f}% de los casos',\n        f'De los predichos como letales, {precision*100:.1f}% son realmente letales',\n        f'Detecta el {recall*100:.1f}% de los siniestros letales reales',\n        f'Balance entre precision y recall: {f1:.3f}',\n        f'Capacidad de discriminación: {roc_auc:.3f}'\n    ]\n})\n\nprint(metricas.to_string(index=False))\n\n\n=== EVALUACIÓN DEL MODELO ===\n  Métrica    Valor                                             Interpretación\n Accuracy 0.923765              Clasifica correctamente el 92.4% de los casos\nPrecision 0.661017 De los predichos como letales, 66.1% son realmente letales\n   Recall 0.098985           Detecta el 9.9% de los siniestros letales reales\n F1-Score 0.172185                    Balance entre precision y recall: 0.172\n  ROC-AUC 0.812082                         Capacidad de discriminación: 0.812\n\n\n\n\nCode\nprint(\"\\nReporte de clasificación detallado:\")\nprint(classification_report(y_test, y_pred, target_names=['No Letal', 'Letal']))\n\n\n\nReporte de clasificación detallado:\n              precision    recall  f1-score   support\n\n    No Letal       0.93      1.00      0.96      4525\n       Letal       0.66      0.10      0.17       394\n\n    accuracy                           0.92      4919\n   macro avg       0.79      0.55      0.57      4919\nweighted avg       0.91      0.92      0.90      4919\n\n\n\n\n\n\n\n\n\n\nCode\nplt.figure(figsize=(8, 6))\ncm = confusion_matrix(y_test, y_pred)\nsns.heatmap(cm, annot=True, fmt='d', cmap='Blues', \n            xticklabels=['No Letal', 'Letal'], \n            yticklabels=['No Letal', 'Letal'])\nplt.title('Matriz de Confusión - Siniestros Letales', fontsize=14, fontweight='bold')\nplt.xlabel('Predicción')\nplt.ylabel('Valor Real')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplt.figure(figsize=(8, 6))\nfpr, tpr, _ = roc_curve(y_test, y_pred_proba)\nplt.plot(fpr, tpr, color='darkorange', lw=3, label=f'ROC curve (AUC = {roc_auc:.3f})')\nplt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--', label='Random Classifier')\nplt.xlim([0.0, 1.0])\nplt.ylim([0.0, 1.05])\nplt.xlabel('Tasa de Falsos Positivos (1 - Especificidad)')\nplt.ylabel('Tasa de Verdaderos Positivos (Sensibilidad)')\nplt.title('Curva ROC - Clasificación de Siniestros Letales', fontsize=14, fontweight='bold')\nplt.legend(loc=\"lower right\")\nplt.grid(alpha=0.3)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplt.figure(figsize=(10, 6))\nplt.hist(y_pred_proba[y_test==0], bins=40, alpha=0.7, label='No Letal', color='skyblue', density=True)\nplt.hist(y_pred_proba[y_test==1], bins=40, alpha=0.7, label='Letal', color='salmon', density=True)\nplt.xlabel('Probabilidad Predicha de Siniestro Letal')\nplt.ylabel('Densidad')\nplt.title('Distribución de Probabilidades Predichas por Clase', fontsize=14, fontweight='bold')\nplt.legend()\nplt.grid(alpha=0.3)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Importancia de features (coeficientes del modelo logístico)\nfeature_names = (numerical_features + \n                list(pipeline.named_steps['preprocessor']\n                    .named_transformers_['cat']\n                    .get_feature_names_out(categorical_features)))\n\ncoefficients = pipeline.named_steps['classifier'].coef_[0]\n\n# Crear DataFrame con importancias\nfeature_importance = pd.DataFrame({\n    'feature': feature_names,\n    'coefficient': coefficients,\n    'abs_coefficient': np.abs(coefficients)\n}).sort_values('abs_coefficient', ascending=False)\n\nprint(\"Top 10 features más importantes:\")\nprint(feature_importance.head(10))\n\n\nTop 10 features más importantes:\n                                    feature  coefficient  abs_coefficient\n78                         CANTON_EL CARMEN     2.068902         2.068902\n211                CLASE_CAÍDA DE PASAJEROS    -1.945683         1.945683\n22                       PROVINCIA_COTOPAXI     1.915295         1.915295\n157                     CANTON_PUERTO QUITO     1.656893         1.656893\n75   CANTON_DISTRITO METROPOLITANO DE QUITO    -1.553377         1.553377\n208                        CANTON_ZAPOTILLO     1.536846         1.536846\n175                       CANTON_SAN MIGUEL    -1.486144         1.486144\n216                       CLASE_ROZAMIENTOS    -1.389880         1.389880\n77                         CANTON_ECHEANDIA     1.294437         1.294437\n122                      CANTON_MONTECRISTI    -1.237940         1.237940\n\n\n\n\nCode\n# Visualizar top features\nplt.figure(figsize=(12, 8))\ntop_features = feature_importance.head(15)\ncolors = ['red' if coef &lt; 0 else 'green' for coef in top_features['coefficient']]\nplt.barh(range(len(top_features)), top_features['coefficient'], color=colors)\nplt.yticks(range(len(top_features)), top_features['feature'])\nplt.xlabel('Coeficiente')\nplt.title('Top 15 Features más Importantes (Coeficientes del Modelo Logístico)', fontsize=14, fontweight='bold')\nplt.grid(axis='x', alpha=0.3)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEl modelo de clasificación binaria muestra los siguientes resultados:\n\nAccuracy (92.4%): Excelente capacidad de clasificación general\nROC-AUC (0.81): Excelente capacidad de discriminación entre clases\nPrecision (66.1%): Moderada - algunos falsos positivos\nRecall (9.9%): Baja - muchos siniestros letales no detectados\n\n\n\n\nLos factores más importantes para predecir siniestros letales incluyen:\n\nUbicación geográfica: Ciertos cantones y provincias muestran mayor riesgo\nTipo de siniestro: Algunas clases de accidentes son más letales que otras\nCausa del accidente: Factores como exceso de velocidad o embriaguez\nZona: Diferencias entre áreas urbanas y rurales\n\n\n\n\n\nClases desbalanceadas: Solo 8% de siniestros son letales\nRecall bajo: El modelo es conservador, prefiere no clasificar como letal\nAplicación práctica: Útil para identificar zonas y factores de alto riesgo\n\n\n\n\n\n\nEl modelo identifica patrones geográficos claros en la letalidad de accidentes\nFactores estructurales (ubicación, tipo de vía) son más predictivos que temporales\nAplicaciones en política pública: Asignación de recursos de emergencia y prevención\nMejoras futuras: Balanceo de clases y features adicionales podrían mejorar el recall"
  },
  {
    "objectID": "clasificacion_binaria.html#introducción",
    "href": "clasificacion_binaria.html#introducción",
    "title": "Clasificación Binaria - Siniestros de Tránsito Letales",
    "section": "",
    "text": "Este documento presenta un modelo de clasificación binaria para predecir si un siniestro de tránsito será letal (con fallecidos) o no letal, utilizando datos del INEC Ecuador 2019.\nObjetivo: Desarrollar un sistema predictivo que identifique factores de riesgo asociados con la letalidad de accidentes de tránsito."
  },
  {
    "objectID": "clasificacion_binaria.html#carga-y-exploración-del-dataset",
    "href": "clasificacion_binaria.html#carga-y-exploración-del-dataset",
    "title": "Clasificación Binaria - Siniestros de Tránsito Letales",
    "section": "",
    "text": "Code\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler, LabelEncoder\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.metrics import (accuracy_score, precision_score, recall_score, \n                           f1_score, confusion_matrix, classification_report, \n                           roc_curve, auc, roc_auc_score)\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Configurar matplotlib\nplt.style.use('default')\nsns.set_palette(\"husl\")\n\nprint(\"=== SISTEMA DE CLASIFICACIÓN BINARIA - SINIESTROS LETALES ===\")\n\n\n=== SISTEMA DE CLASIFICACIÓN BINARIA - SINIESTROS LETALES ===\n\n\n\n\nCode\n# Cargar datos\ndf = pd.read_csv('DATOS_CLASIFICACION_BINARIA/inec_anuario-de-estadisticas-de-transporte_siniestros-de-transito_2019.csv', \n                 sep=';', encoding='utf-8')\n\nprint(f\"Datos cargados: {df.shape[0]} filas, {df.shape[1]} columnas\")\nprint(\"\\nPrimeras 5 filas:\")\ndf.head()\n\n\nDatos cargados: 24595 filas, 11 columnas\n\nPrimeras 5 filas:\n\n\n\n\n\n\n\n\n\nMES\nDIA\nHORA\nPROVINCIA\nCANTON\nZONA\nNUM_FALLECIDO\nNUM_LESIONADO\nTOTAL_VICTIMAS\nCLASE\nCAUSA\n\n\n\n\n0\nENERO\nMARTES\n11:00 A 11:59\nIMBABURA\nOTAVALO\nURBANA\n0\n0\n0\nPÉRDIDA DE PISTA\nIMPERICIA E IMPRUDENCIA DEL CONDUCTOR\n\n\n1\nENERO\nMARTES\n23:00 A 23:59\nIMBABURA\nIBARRA\nRURAL\n0\n0\n0\nOTROS\nOTRAS CAUSAS\n\n\n2\nENERO\nMARTES\n12:00 A 12:59\nTUNGURAHUA\nAMBATO\nURBANA\n0\n3\n3\nCHOQUES\nNO RESPETA LAS SEÑALES DE TRÁNSITO\n\n\n3\nENERO\nMARTES\n07:00 A 07:59\nTUNGURAHUA\nAMBATO\nRURAL\n0\n1\n1\nATROPELLOS\nEMBRIAGUEZ O DROGA\n\n\n4\nENERO\nMARTES\n04:00 A 04:59\nPICHINCHA\nDISTRITO METROPOLITANO DE QUITO\nURBANA\n0\n0\n0\nESTRELLAMIENTOS\nEXCESO VELOCIDAD\n\n\n\n\n\n\n\n\n\nCode\n# Exploración inicial\nprint(\"=== EXPLORACIÓN DE DATOS ===\")\nprint(f\"Columnas: {list(df.columns)}\")\nprint(f\"\\nValores faltantes por columna:\")\ndf.isnull().sum()\n\n\n=== EXPLORACIÓN DE DATOS ===\nColumnas: ['MES', 'DIA', 'HORA', 'PROVINCIA', 'CANTON', 'ZONA', 'NUM_FALLECIDO', 'NUM_LESIONADO', 'TOTAL_VICTIMAS', 'CLASE', 'CAUSA']\n\nValores faltantes por columna:\n\n\nMES               0\nDIA               0\nHORA              0\nPROVINCIA         0\nCANTON            0\nZONA              0\nNUM_FALLECIDO     0\nNUM_LESIONADO     0\nTOTAL_VICTIMAS    0\nCLASE             0\nCAUSA             0\ndtype: int64"
  },
  {
    "objectID": "clasificacion_binaria.html#definición-de-la-variable-objetivo",
    "href": "clasificacion_binaria.html#definición-de-la-variable-objetivo",
    "title": "Clasificación Binaria - Siniestros de Tránsito Letales",
    "section": "",
    "text": "Code\n# Crear variable objetivo binaria\nprint(\"=== CREANDO VARIABLE OBJETIVO ===\")\ndf['SINIESTRO_LETAL'] = (df['NUM_FALLECIDO'] &gt; 0).astype(int)\n\nprint(f\"Distribución de la variable objetivo:\")\nprint(df['SINIESTRO_LETAL'].value_counts())\nprint(f\"Porcentaje de siniestros letales: {df['SINIESTRO_LETAL'].mean()*100:.2f}%\")\n\n# Visualizar distribución\nplt.figure(figsize=(8, 5))\ndf['SINIESTRO_LETAL'].value_counts().plot(kind='bar', color=['skyblue', 'salmon'])\nplt.title('Distribución de Siniestros: Letales vs No Letales')\nplt.xlabel('Tipo de Siniestro')\nplt.ylabel('Cantidad')\nplt.xticks([0, 1], ['No Letal', 'Letal'], rotation=0)\nplt.show()\n\n\n=== CREANDO VARIABLE OBJETIVO ===\nDistribución de la variable objetivo:\n0    22626\n1     1969\nName: SINIESTRO_LETAL, dtype: int64\nPorcentaje de siniestros letales: 8.01%"
  },
  {
    "objectID": "clasificacion_binaria.html#preparación-de-features",
    "href": "clasificacion_binaria.html#preparación-de-features",
    "title": "Clasificación Binaria - Siniestros de Tránsito Letales",
    "section": "",
    "text": "Code\nprint(\"=== PREPARANDO FEATURES ===\")\n# Seleccionar columnas para el modelo\nfeature_cols = ['MES', 'DIA', 'HORA', 'PROVINCIA', 'CANTON', 'ZONA', 'CLASE', 'CAUSA']\nX = df[feature_cols].copy()\ny = df['SINIESTRO_LETAL']\n\nprint(f\"Features seleccionadas: {feature_cols}\")\nprint(f\"Forma de X: {X.shape}\")\n\n# Procesar la columna HORA para extraer la hora numérica\ndef extract_hour(hora_str):\n    try:\n        return int(hora_str.split(':')[0])\n    except:\n        return 12  # valor por defecto\n\nX['HORA_NUM'] = X['HORA'].apply(extract_hour)\nX = X.drop('HORA', axis=1)\n\n# Identificar variables categóricas y numéricas\ncategorical_features = ['MES', 'DIA', 'PROVINCIA', 'CANTON', 'ZONA', 'CLASE', 'CAUSA']\nnumerical_features = ['HORA_NUM']\n\nprint(f\"Features categóricas: {categorical_features}\")\nprint(f\"Features numéricas: {numerical_features}\")\n\n\n=== PREPARANDO FEATURES ===\nFeatures seleccionadas: ['MES', 'DIA', 'HORA', 'PROVINCIA', 'CANTON', 'ZONA', 'CLASE', 'CAUSA']\nForma de X: (24595, 8)\nFeatures categóricas: ['MES', 'DIA', 'PROVINCIA', 'CANTON', 'ZONA', 'CLASE', 'CAUSA']\nFeatures numéricas: ['HORA_NUM']"
  },
  {
    "objectID": "clasificacion_binaria.html#división-de-datos",
    "href": "clasificacion_binaria.html#división-de-datos",
    "title": "Clasificación Binaria - Siniestros de Tránsito Letales",
    "section": "",
    "text": "Code\nprint(\"=== DIVIDIENDO DATOS ===\")\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42, stratify=y\n)\n\nprint(f\"Entrenamiento: {X_train.shape[0]} muestras\")\nprint(f\"Prueba: {X_test.shape[0]} muestras\")\nprint(f\"Distribución en entrenamiento:\")\nprint(y_train.value_counts(normalize=True))\n\n\n=== DIVIDIENDO DATOS ===\nEntrenamiento: 19676 muestras\nPrueba: 4919 muestras\nDistribución en entrenamiento:\n0    0.919953\n1    0.080047\nName: SINIESTRO_LETAL, dtype: float64"
  },
  {
    "objectID": "clasificacion_binaria.html#definición-y-entrenamiento-del-modelo",
    "href": "clasificacion_binaria.html#definición-y-entrenamiento-del-modelo",
    "title": "Clasificación Binaria - Siniestros de Tránsito Letales",
    "section": "",
    "text": "Code\nprint(\"=== CREANDO PIPELINE ===\")\n# Crear pipeline de preprocesamiento\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('num', StandardScaler(), numerical_features),\n        ('cat', OneHotEncoder(drop='first', handle_unknown='ignore'), categorical_features)\n    ])\n\n# Pipeline completo\npipeline = Pipeline([\n    ('preprocessor', preprocessor),\n    ('classifier', LogisticRegression(random_state=42, max_iter=1000))\n])\n\n# Entrenar modelo\nprint(\"Entrenando modelo LogisticRegression...\")\npipeline.fit(X_train, y_train)\nprint(\"✓ Modelo entrenado exitosamente\")\n\n\n=== CREANDO PIPELINE ===\nEntrenando modelo LogisticRegression...\n✓ Modelo entrenado exitosamente"
  },
  {
    "objectID": "clasificacion_binaria.html#generación-de-predicciones",
    "href": "clasificacion_binaria.html#generación-de-predicciones",
    "title": "Clasificación Binaria - Siniestros de Tránsito Letales",
    "section": "",
    "text": "Code\nprint(\"=== REALIZANDO PREDICCIONES ===\")\ny_pred = pipeline.predict(X_test)\ny_pred_proba = pipeline.predict_proba(X_test)[:, 1]\n\nprint(f\"Predicciones generadas para {len(y_pred)} muestras\")\nprint(f\"Distribución de predicciones:\")\nprint(pd.Series(y_pred).value_counts())\n\n\n=== REALIZANDO PREDICCIONES ===\nPredicciones generadas para 4919 muestras\nDistribución de predicciones:\n0    4860\n1      59\ndtype: int64"
  },
  {
    "objectID": "clasificacion_binaria.html#evaluación-del-modelo",
    "href": "clasificacion_binaria.html#evaluación-del-modelo",
    "title": "Clasificación Binaria - Siniestros de Tránsito Letales",
    "section": "",
    "text": "Code\nprint(\"=== EVALUACIÓN DEL MODELO ===\")\naccuracy = accuracy_score(y_test, y_pred)\nprecision = precision_score(y_test, y_pred)\nrecall = recall_score(y_test, y_pred)\nf1 = f1_score(y_test, y_pred)\nroc_auc = roc_auc_score(y_test, y_pred_proba)\n\n# Crear DataFrame con métricas\nmetricas = pd.DataFrame({\n    'Métrica': ['Accuracy', 'Precision', 'Recall', 'F1-Score', 'ROC-AUC'],\n    'Valor': [accuracy, precision, recall, f1, roc_auc],\n    'Interpretación': [\n        f'Clasifica correctamente el {accuracy*100:.1f}% de los casos',\n        f'De los predichos como letales, {precision*100:.1f}% son realmente letales',\n        f'Detecta el {recall*100:.1f}% de los siniestros letales reales',\n        f'Balance entre precision y recall: {f1:.3f}',\n        f'Capacidad de discriminación: {roc_auc:.3f}'\n    ]\n})\n\nprint(metricas.to_string(index=False))\n\n\n=== EVALUACIÓN DEL MODELO ===\n  Métrica    Valor                                             Interpretación\n Accuracy 0.923765              Clasifica correctamente el 92.4% de los casos\nPrecision 0.661017 De los predichos como letales, 66.1% son realmente letales\n   Recall 0.098985           Detecta el 9.9% de los siniestros letales reales\n F1-Score 0.172185                    Balance entre precision y recall: 0.172\n  ROC-AUC 0.812082                         Capacidad de discriminación: 0.812\n\n\n\n\nCode\nprint(\"\\nReporte de clasificación detallado:\")\nprint(classification_report(y_test, y_pred, target_names=['No Letal', 'Letal']))\n\n\n\nReporte de clasificación detallado:\n              precision    recall  f1-score   support\n\n    No Letal       0.93      1.00      0.96      4525\n       Letal       0.66      0.10      0.17       394\n\n    accuracy                           0.92      4919\n   macro avg       0.79      0.55      0.57      4919\nweighted avg       0.91      0.92      0.90      4919"
  },
  {
    "objectID": "clasificacion_binaria.html#visualizaciones",
    "href": "clasificacion_binaria.html#visualizaciones",
    "title": "Clasificación Binaria - Siniestros de Tránsito Letales",
    "section": "",
    "text": "Code\nplt.figure(figsize=(8, 6))\ncm = confusion_matrix(y_test, y_pred)\nsns.heatmap(cm, annot=True, fmt='d', cmap='Blues', \n            xticklabels=['No Letal', 'Letal'], \n            yticklabels=['No Letal', 'Letal'])\nplt.title('Matriz de Confusión - Siniestros Letales', fontsize=14, fontweight='bold')\nplt.xlabel('Predicción')\nplt.ylabel('Valor Real')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplt.figure(figsize=(8, 6))\nfpr, tpr, _ = roc_curve(y_test, y_pred_proba)\nplt.plot(fpr, tpr, color='darkorange', lw=3, label=f'ROC curve (AUC = {roc_auc:.3f})')\nplt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--', label='Random Classifier')\nplt.xlim([0.0, 1.0])\nplt.ylim([0.0, 1.05])\nplt.xlabel('Tasa de Falsos Positivos (1 - Especificidad)')\nplt.ylabel('Tasa de Verdaderos Positivos (Sensibilidad)')\nplt.title('Curva ROC - Clasificación de Siniestros Letales', fontsize=14, fontweight='bold')\nplt.legend(loc=\"lower right\")\nplt.grid(alpha=0.3)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplt.figure(figsize=(10, 6))\nplt.hist(y_pred_proba[y_test==0], bins=40, alpha=0.7, label='No Letal', color='skyblue', density=True)\nplt.hist(y_pred_proba[y_test==1], bins=40, alpha=0.7, label='Letal', color='salmon', density=True)\nplt.xlabel('Probabilidad Predicha de Siniestro Letal')\nplt.ylabel('Densidad')\nplt.title('Distribución de Probabilidades Predichas por Clase', fontsize=14, fontweight='bold')\nplt.legend()\nplt.grid(alpha=0.3)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "clasificacion_binaria.html#análisis-de-importancia-de-features",
    "href": "clasificacion_binaria.html#análisis-de-importancia-de-features",
    "title": "Clasificación Binaria - Siniestros de Tránsito Letales",
    "section": "",
    "text": "Code\n# Importancia de features (coeficientes del modelo logístico)\nfeature_names = (numerical_features + \n                list(pipeline.named_steps['preprocessor']\n                    .named_transformers_['cat']\n                    .get_feature_names_out(categorical_features)))\n\ncoefficients = pipeline.named_steps['classifier'].coef_[0]\n\n# Crear DataFrame con importancias\nfeature_importance = pd.DataFrame({\n    'feature': feature_names,\n    'coefficient': coefficients,\n    'abs_coefficient': np.abs(coefficients)\n}).sort_values('abs_coefficient', ascending=False)\n\nprint(\"Top 10 features más importantes:\")\nprint(feature_importance.head(10))\n\n\nTop 10 features más importantes:\n                                    feature  coefficient  abs_coefficient\n78                         CANTON_EL CARMEN     2.068902         2.068902\n211                CLASE_CAÍDA DE PASAJEROS    -1.945683         1.945683\n22                       PROVINCIA_COTOPAXI     1.915295         1.915295\n157                     CANTON_PUERTO QUITO     1.656893         1.656893\n75   CANTON_DISTRITO METROPOLITANO DE QUITO    -1.553377         1.553377\n208                        CANTON_ZAPOTILLO     1.536846         1.536846\n175                       CANTON_SAN MIGUEL    -1.486144         1.486144\n216                       CLASE_ROZAMIENTOS    -1.389880         1.389880\n77                         CANTON_ECHEANDIA     1.294437         1.294437\n122                      CANTON_MONTECRISTI    -1.237940         1.237940\n\n\n\n\nCode\n# Visualizar top features\nplt.figure(figsize=(12, 8))\ntop_features = feature_importance.head(15)\ncolors = ['red' if coef &lt; 0 else 'green' for coef in top_features['coefficient']]\nplt.barh(range(len(top_features)), top_features['coefficient'], color=colors)\nplt.yticks(range(len(top_features)), top_features['feature'])\nplt.xlabel('Coeficiente')\nplt.title('Top 15 Features más Importantes (Coeficientes del Modelo Logístico)', fontsize=14, fontweight='bold')\nplt.grid(axis='x', alpha=0.3)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "clasificacion_binaria.html#interpretación-de-resultados",
    "href": "clasificacion_binaria.html#interpretación-de-resultados",
    "title": "Clasificación Binaria - Siniestros de Tránsito Letales",
    "section": "",
    "text": "El modelo de clasificación binaria muestra los siguientes resultados:\n\nAccuracy (92.4%): Excelente capacidad de clasificación general\nROC-AUC (0.81): Excelente capacidad de discriminación entre clases\nPrecision (66.1%): Moderada - algunos falsos positivos\nRecall (9.9%): Baja - muchos siniestros letales no detectados\n\n\n\n\nLos factores más importantes para predecir siniestros letales incluyen:\n\nUbicación geográfica: Ciertos cantones y provincias muestran mayor riesgo\nTipo de siniestro: Algunas clases de accidentes son más letales que otras\nCausa del accidente: Factores como exceso de velocidad o embriaguez\nZona: Diferencias entre áreas urbanas y rurales\n\n\n\n\n\nClases desbalanceadas: Solo 8% de siniestros son letales\nRecall bajo: El modelo es conservador, prefiere no clasificar como letal\nAplicación práctica: Útil para identificar zonas y factores de alto riesgo"
  },
  {
    "objectID": "clasificacion_binaria.html#conclusiones",
    "href": "clasificacion_binaria.html#conclusiones",
    "title": "Clasificación Binaria - Siniestros de Tránsito Letales",
    "section": "",
    "text": "El modelo identifica patrones geográficos claros en la letalidad de accidentes\nFactores estructurales (ubicación, tipo de vía) son más predictivos que temporales\nAplicaciones en política pública: Asignación de recursos de emergencia y prevención\nMejoras futuras: Balanceo de clases y features adicionales podrían mejorar el recall"
  },
  {
    "objectID": "ml_text.html",
    "href": "ml_text.html",
    "title": "Cargar datos",
    "section": "",
    "text": "Code\nimport pandas as pd\nimport requests\nimport nltk\n# downloading some additional packages and corpora\nnltk.download('punkt', quiet=True) # necessary for tokenization\nnltk.download('punkt_tab', quiet=True) # necessary for tokenization\nnltk.download('wordnet', quiet=True) # necessary for lemmatization\nnltk.download('stopwords', quiet=True) # necessary for removal of stop words\nnltk.download('averaged_perceptron_tagger', quiet=True) # necessary for POS tagging\nnltk.download('averaged_perceptron_tagger_eng', quiet=True) # necessary for POS tagging\nnltk.download('maxent_ne_chunker', quiet=True) # necessary for entity extraction\nnltk.download('omw-1.4', quiet=True) # necessary for lemmatization\nnltk.download('words', quiet=True)\nprint(\"NLTK resources downloaded successfully\")\n\n\nNLTK resources downloaded successfully\n\n\n\n\nCode\nurl = \"https://raw.githubusercontent.com/erickedu85/dataset/master/story.txt\"\n\nr = requests.get(url)\n\nr.encoding = 'utf-8'\nstory = r.text\nprint(story[:20])\nprint('este fue el texto')\n\n\nThe seventh Sally or\neste fue el texto\n\n\n\nTokenización\n\n\nCode\nfrom nltk import word_tokenize,pos_tag\n\nwords = word_tokenize(story)\nwords[:20]\n\n\n['The',\n 'seventh',\n 'Sally',\n 'or',\n 'how',\n 'Trurl',\n \"'s\",\n 'own',\n 'perfection',\n 'led',\n 'to',\n 'no',\n 'good',\n 'By',\n 'StanisÅ‚aw',\n 'Lem',\n ',',\n '1965',\n '.',\n 'Translated']\n\n\n\n\nStriming and Lemmatización\n\n\nCode\nfrom nltk.stem import PorterStemmer as stemmer\nfrom nltk.stem import WordNetLemmatizer as lemmatizer\nfrom nltk.corpus import wordnet\n\npalabra = 'changing'\nprint(\"palabra:\",palabra)\n#steaming\nprint(\"stemming:\",stemmer().stem(palabra))\n\n#lemmatización\nprint(\"lemmatización:\",lemmatizer().lemmatize(palabra,pos= wordnet.VERB))\n\n\npalabra: changing\nstemming: chang\nlemmatización: change\n\n\n\n\nPART OF SPEECH - POS TAG\n\n\nCode\nfrom nltk import pos_tag\npos_tag(words[:20])\n\n\n[('The', 'DT'),\n ('seventh', 'JJ'),\n ('Sally', 'NNP'),\n ('or', 'CC'),\n ('how', 'WRB'),\n ('Trurl', 'NNP'),\n (\"'s\", 'POS'),\n ('own', 'JJ'),\n ('perfection', 'NN'),\n ('led', 'VBD'),\n ('to', 'TO'),\n ('no', 'DT'),\n ('good', 'JJ'),\n ('By', 'IN'),\n ('StanisÅ‚aw', 'NNP'),\n ('Lem', 'NNP'),\n (',', ','),\n ('1965', 'CD'),\n ('.', '.'),\n ('Translated', 'VBN')]\n\n\n\n\nStop words\n\n\nCode\nfrom nltk.corpus import stopwords as stop\nstopwords = stop.words('english')\nstopwords[:20]\n\n#fin de script\n\n\n['a',\n 'about',\n 'above',\n 'after',\n 'again',\n 'against',\n 'ain',\n 'all',\n 'am',\n 'an',\n 'and',\n 'any',\n 'are',\n 'aren',\n \"aren't\",\n 'as',\n 'at',\n 'be',\n 'because',\n 'been']\n\n\n\n\nstop words in story\n\n\nCode\ntokens = nltk.word_tokenize(story.lower())\n\n#limpieza de nuemero\nlettertokens = [token for token in tokens if token.isalpha()]\n\nwithout_stopwords = [token for token in lettertokens if token not in stopwords]\nwithout_stopwords[:20]\n\n#fin de script\n\n\n['seventh',\n 'sally',\n 'trurl',\n 'perfection',\n 'led',\n 'good',\n 'lem',\n 'translated',\n 'michael',\n 'kandel',\n 'universe',\n 'infinite',\n 'bounded',\n 'therefore',\n 'beam',\n 'light',\n 'whatever',\n 'direction',\n 'may',\n 'travel']"
  },
  {
    "objectID": "text_classification.html",
    "href": "text_classification.html",
    "title": "Text Classification",
    "section": "",
    "text": "Importar librerías\n\nfrom sklearn.feature_extraction.text import CountVectorizer #BoW\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.naive_bayes import MultinomialNB\nfrom sklearn.metrics import classification_report\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.datasets import fetch_20newsgroups\nimport pandas as pd\nimport nltk\nfrom nltk.corpus import stopwords\nfrom nltk import word_tokenize # tokenizacion\nfrom nltk import pos_tag #lematizacion\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk.corpus import wordnet\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.metrics import confusion_matrix\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n#stop words\nlemmatizer = WordNetLemmatizer()\n\nnltk.download('stopwords') # necessary for removal of stop words\nnltk.download('wordnet') # necessary for lemmatization\n\n[nltk_data] Downloading package stopwords to\n[nltk_data]     /home/juanchx/nltk_data...\n[nltk_data]   Package stopwords is already up-to-date!\n[nltk_data] Downloading package wordnet to /home/juanchx/nltk_data...\n[nltk_data]   Package wordnet is already up-to-date!\n\n\nTrue\n\n\n\n\ncargar dataset\n\ncategories = ['comp.graphics','comp.sys.mac.hardware','rec.sport.baseball','talk.politics.misc']\nnewsgroups = fetch_20newsgroups(subset='train',categories=categories,remove=('headers','footers','quotes'))\nprint(newsgroups.target_names)\n\n#fin\n\n['comp.graphics', 'comp.sys.mac.hardware', 'rec.sport.baseball', 'talk.politics.misc']\n\n\n\n\nFeatures and target\n\nX = newsgroups.data\ny = newsgroups.target\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)\nstop_words = stopwords.words('english')\nvectoizer = TfidfVectorizer(stop_words=stop_words)\nvectoizer = CountVectorizer(stop_words=stop_words)\n\nnaive_bayes = MultinomialNB()\n#pipelline \npipe = Pipeline([\n      (\"vectorizacion\",vectoizer),\n      (\"naive_bayes\",naive_bayes)\n])\n\n#end script\n\n#entrenamiento\n\npipe.fit(X_train,y_train)\n\nPipeline(steps=[('vectorizacion',\n                 CountVectorizer(stop_words=['a', 'about', 'above', 'after',\n                                             'again', 'against', 'ain', 'all',\n                                             'am', 'an', 'and', 'any', 'are',\n                                             'aren', \"aren't\", 'as', 'at', 'be',\n                                             'because', 'been', 'before',\n                                             'being', 'below', 'between',\n                                             'both', 'but', 'by', 'can',\n                                             'couldn', \"couldn't\", ...])),\n                ('naive_bayes', MultinomialNB())])In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.PipelinePipeline(steps=[('vectorizacion',\n                 CountVectorizer(stop_words=['a', 'about', 'above', 'after',\n                                             'again', 'against', 'ain', 'all',\n                                             'am', 'an', 'and', 'any', 'are',\n                                             'aren', \"aren't\", 'as', 'at', 'be',\n                                             'because', 'been', 'before',\n                                             'being', 'below', 'between',\n                                             'both', 'but', 'by', 'can',\n                                             'couldn', \"couldn't\", ...])),\n                ('naive_bayes', MultinomialNB())])CountVectorizerCountVectorizer(stop_words=['a', 'about', 'above', 'after', 'again', 'against',\n                            'ain', 'all', 'am', 'an', 'and', 'any', 'are',\n                            'aren', \"aren't\", 'as', 'at', 'be', 'because',\n                            'been', 'before', 'being', 'below', 'between',\n                            'both', 'but', 'by', 'can', 'couldn', \"couldn't\", ...])MultinomialNBMultinomialNB()\n\n\n#predicción\n\ny_pred = pipe.predict(X_test)\n\n#reporte\n\n#track the name of the categories\nprint(classification_report(y_test,y_pred,target_names=newsgroups.target_names))\n\n                       precision    recall  f1-score   support\n\n        comp.graphics       0.92      0.91      0.91       117\ncomp.sys.mac.hardware       0.91      0.92      0.91       116\n   rec.sport.baseball       0.90      0.90      0.90       119\n   talk.politics.misc       0.89      0.89      0.89        93\n\n             accuracy                           0.91       445\n            macro avg       0.91      0.91      0.90       445\n         weighted avg       0.91      0.91      0.91       445\n\n\n\n\n\nMatriz de confusión\n\nfrom sklearn.metrics import ConfusionMatrixDisplay\ndisp = ConfusionMatrixDisplay(confusion_matrix(y_test,y_pred),display_labels=newsgroups.target_names)\ndisp.plot()\nplt.xticks(rotation=90)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "Landos.html",
    "href": "Landos.html",
    "title": "Clasificación de Tweets - Predicción de Popularidad",
    "section": "",
    "text": "Predicción del nivel de popularidad de usuarios de Twitter basándose en el contenido de sus tweets.\nHipótesis: El estilo de escritura revela información sobre la popularidad del autor."
  },
  {
    "objectID": "Landos.html#resultados",
    "href": "Landos.html#resultados",
    "title": "Clasificación de Tweets - Predicción de Popularidad",
    "section": "Resultados",
    "text": "Resultados\n\nAccuracy Test: ~56% (supera baseline 33.3%)\nMejor predicha: BAJA (recall ~0.81)\nMás difícil: MEDIA (recall ~0.26)"
  },
  {
    "objectID": "Landos.html#interpretación",
    "href": "Landos.html#interpretación",
    "title": "Clasificación de Tweets - Predicción de Popularidad",
    "section": "Interpretación",
    "text": "Interpretación\nEl estilo de escritura SÍ contiene información sobre popularidad:\n\nUsuarios con BAJA popularidad: patrones distintivos\nClase MEDIA: difícil de diferenciar\nUsuarios ALTA: moderadamente distinguibles"
  },
  {
    "objectID": "Landos.html#aplicaciones",
    "href": "Landos.html#aplicaciones",
    "title": "Clasificación de Tweets - Predicción de Popularidad",
    "section": "Aplicaciones",
    "text": "Aplicaciones\n\nIdentificar cuentas influyentes por contenido\nDetectar patrones de popularidad\nSegmentación de usuarios"
  },
  {
    "objectID": "lab2.html",
    "href": "lab2.html",
    "title": "Clasificación de Tweets: Predicción de Popularidad de Usuarios",
    "section": "",
    "text": "Introducción\nEste análisis tiene como objetivo predecir el nivel de popularidad de usuarios de Twitter basándose en el contenido de sus tweets y características asociadas. Utilizamos técnicas de Machine Learning para clasificación de texto y análisis de patrones de comportamiento.\nHipótesis: El estilo de escritura y las características de los tweets pueden revelar información sobre la popularidad del autor (medida por número de seguidores).\n\n\n1. Carga y Exploración del Dataset\n#| label: setup #| echo: true\nimport pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn as sns import re from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.compose import ColumnTransformer from sklearn.pipeline import Pipeline from sklearn.linear_model import LogisticRegression from sklearn.metrics import ( classification_report, confusion_matrix, ConfusionMatrixDisplay, accuracy_score, precision_recall_fscore_support )\n\n\nConfiguración de visualización\nplt.style.use(‘seaborn-v0_8-darkgrid’) sns.set_palette(“husl”)\n\n\nCargar dataset\ndf = pd.read_csv(‘data_twwet/tweets_totales_con_sentimiento_ml.csv’)\nprint(f”Total de registros: {len(df):,}“) print(f”Autores únicos: {df[‘authorId’].nunique():,}“) print(f”Periodo: {df[‘createdAt’].min()} a {df[‘createdAt’].max()}“)"
  }
]